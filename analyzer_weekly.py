#!/usr/bin/env python3
"""
Analyzer for BTC long vs ALT short backtest using weekly top-100 snapshots.
Data source: top100_weekly_2021-2025.csv (generated by fetcher.py).
"""
from pathlib import Path
import pandas as pd
import matplotlib.pyplot as plt
from matplotlib.ticker import ScalarFormatter, PercentFormatter
import datetime as dt
import numpy as np

# Import configuration
from config.config import (
    EXCLUDED_SYMBOLS,
    BACKTEST_START_DATE,
    BACKTEST_END_DATE,
    BACKTEST_INITIAL_CAPITAL,
    BACKTEST_BTC_WEIGHT,
    BACKTEST_ALT_WEIGHT,
    BACKTEST_TOP_N_ALTS
)

# Configuration with defaults from config.py
CSV_PATH = Path("top100_weekly_2021-2025.csv")
START_CAP = BACKTEST_INITIAL_CAPITAL
BTC_W = BACKTEST_BTC_WEIGHT
ALT_W = BACKTEST_ALT_WEIGHT
TOP_N = BACKTEST_TOP_N_ALTS
EXCLUDED = EXCLUDED_SYMBOLS
# Date range for backtesting
START_DATE = BACKTEST_START_DATE
END_DATE = BACKTEST_END_DATE
# Output directory for detailed reports
REPORTS_DIR = Path("reports")


def load_and_prepare(csv_path: Path, start_date=None, end_date=None) -> pd.DataFrame:
    """
    Load CSV from csv_path, clean numeric columns, compute price_btc and mcap_btc columns.
    Optionally filters data by date range.
    
    Args:
        csv_path: Path to the CSV file
        start_date: Optional start date to filter data (inclusive)
        end_date: Optional end date to filter data (inclusive)
        
    Returns:
        DataFrame compatible with backtest_rank_altbtc_short.
    """
    df = pd.read_csv(csv_path)
    # parse date
    df["snapshot_date"] = pd.to_datetime(df["snapshot_date"])
    
    # Filter by date range if provided
    if start_date:
        df = df[df["snapshot_date"] >= pd.Timestamp(start_date)]
    if end_date:
        df = df[df["snapshot_date"] <= pd.Timestamp(end_date)]
        
    # rename to match old analyzer expectations
    df = df.rename(
        columns={
            "snapshot_date": "rebalance_ts",
            "symbol": "sym",
            "price": "price_usd",
            "market_cap": "market_cap_usd",
        }
    )
    # clean numeric columns
    for col in ["price_usd", "market_cap_usd", "volume_24h"]:
        if col in df.columns:
            df[col] = (
                df[col]
                .astype(str)
                .replace(r"[\$,]", "", regex=True)
                .astype(float)
            )
    # map BTC price per week
    btc_prices = (
        df.loc[df["sym"] == "BTC", ["rebalance_ts", "price_usd"]]
        .drop_duplicates()
        .set_index("rebalance_ts")["price_usd"]
    )
    # assign btc_price_usd
    df["btc_price_usd"] = df["rebalance_ts"].map(btc_prices)
    # compute price_btc and mcap_btc
    df["price_btc"] = df["price_usd"] / df["btc_price_usd"]
    df["mcap_btc"] = df["market_cap_usd"] / df["btc_price_usd"]
    # ensure rank integer
    df["rank"] = df["rank"].astype(int)
    # drop rows lacking key data
    df = df.dropna(subset=["rebalance_ts", "sym", "btc_price_usd", "price_usd", "price_btc", "mcap_btc", "rank"])
    return df
    
def backtest_rank_altbtc_short(df: pd.DataFrame,
                               btc_w: float = BTC_W,
                               alt_w: float = ALT_W,
                               top_n: int = TOP_N,
                               excluded: list = None,
                               start_cap: float = START_CAP,
                               detailed_output: bool = True) -> tuple[pd.DataFrame, dict, pd.DataFrame]:
    """
    Backtest the BTC long vs ALT short strategy.
    
    Args:
        df: DataFrame with prepared cryptocurrency data
        btc_w: Weight of BTC position (0-1)
        alt_w: Weight of ALT position (0-1)
        top_n: Number of top altcoins to include in the short basket
        excluded: List of symbols to exclude from the short basket
        start_cap: Initial capital in USD
        detailed_output: Whether to save detailed weekly position data
        
    Returns:
        Tuple of (performance DataFrame, summary dictionary, detailed_positions DataFrame)
    """
    if excluded is None:
        excluded = EXCLUDED
        
    weeks = sorted(df["rebalance_ts"].unique())
    equity = start_cap

    btc_qty = 0.0
    alt_qty: dict[str, float] = {}

    rows = []
    detailed_positions = []  # To store detailed position data for each week
    cum_btc_pnl = cum_alt_pnl = 0.0
    total_alt_pnl_btc = 0.0

    print("--- Backtest Start ---")
    print(f"Strategy: {btc_w * 100}% Long BTC/USD, {alt_w * 100}% Short ALT/BTC (Top {top_n})")
    print(f"Date Range: {pd.Timestamp(weeks[0]).date()} to {pd.Timestamp(weeks[-1]).date()}")
    print(f"Excluded from Alts: {excluded}")
    print(f"Initial Equity: {start_cap:,.2f} USD")
    print("-" * 50)

    for i in range(len(weeks) - 1):
        t0, t1 = weeks[i], weeks[i + 1]
        w0 = df[df.rebalance_ts == t0].set_index('sym')
        w1 = df[df.rebalance_ts == t1].set_index('sym')

        # BTC prices
        try:
            btc_price0 = w0["btc_price_usd"].mean()
            btc_price1 = w1["btc_price_usd"].mean()
            if pd.isna(btc_price0) or pd.isna(btc_price1) or btc_price0 == 0:
                raise ValueError("BTC price is NaN or zero")
        except Exception as e:
            print(f"Error getting BTC price: {e}")
            if i == 0:
                print("Cannot initialize positions without BTC price.")
                return pd.DataFrame(), {}, pd.DataFrame()
            else:
                print("Holding previous positions due to missing BTC price.")
                if rows:
                    last_row = rows[-1]
                    rows.append({**last_row, 'Date': pd.Timestamp(t1), 'BTC_Price_USD': None})
                continue

        # Week performance calculation
        if i == 0:
            # initialize positions
            print(f"{pd.Timestamp(t0).date()} | Initializing positions...")
            btc_qty = (btc_w * equity) / btc_price0
            print(f"  BTC Long: Qty={btc_qty:.6f} BTC @ ${btc_price0:,.2f}/BTC | Value=${btc_qty * btc_price0:,.2f}")

            alt_notional_usd_target = alt_w * equity
            alts_df_t0 = w0[~w0.index.isin(excluded)].nsmallest(top_n, "rank")
            actual_alt_usd_value_total = 0.0
            temp_alt_qty: dict[str, float] = {}
            
            print(f"  Target ALT Short Leg Value: ${alt_notional_usd_target:,.2f}")
            print(f"  Selected ALTs for Short Basket:")
            
            # Create a formatted table for the ALT basket
            if not alts_df_t0.empty:
                tot_mcap = alts_df_t0["mcap_btc"].sum()
                if tot_mcap > 0 and not pd.isna(tot_mcap):
                    # Print table header
                    print(f"    {'Symbol':<6} {'Weight':>8} {'Target USD':>12} {'Qty':>12} {'Price BTC':>12} {'Value USD':>12}")
                    print(f"    {'-'*6:<6} {'-'*8:>8} {'-'*12:>12} {'-'*12:>12} {'-'*12:>12} {'-'*12:>12}")
                    
                    for sym, r in alts_df_t0.iterrows():
                        if not pd.isna(r.price_btc) and r.price_btc != 0 and not pd.isna(r.mcap_btc):
                            alt_usd_target_sym = alt_notional_usd_target * (r.mcap_btc / tot_mcap)
                            qty = -(alt_usd_target_sym / (r.price_btc * btc_price0))
                            temp_alt_qty[sym] = qty
                            actual_usd_value_sym = abs(qty * r.price_btc * btc_price0)
                            actual_alt_usd_value_total += actual_usd_value_sym
                            
                            # Print formatted row
                            print(f"    {sym:<6} {r.mcap_btc / tot_mcap:>7.2%} {alt_usd_target_sym:>12,.2f} {qty:>12,.4f} {r.price_btc:>12.8f} {actual_usd_value_sym:>12,.2f}")
                            
                            # Store detailed position data
                            if detailed_output:
                                detailed_positions.append({
                                    "Date": pd.Timestamp(t0),
                                    "Symbol": sym,
                                    "Type": "SHORT",
                                    "Weight": r.mcap_btc / tot_mcap,
                                    "Quantity": qty,
                                    "Price_BTC": r.price_btc,
                                    "Price_USD": r.price_usd,
                                    "Value_USD": actual_usd_value_sym,
                                    "PnL_BTC": 0.0,
                                    "PnL_USD": 0.0
                                })
                                
                        else:
                            print(f"    {sym:<6} {'N/A':>8} {'N/A':>12} {'N/A':>12} {'N/A':>12} {'N/A':>12}  (invalid price/mcap)")
                            
                    alt_qty = temp_alt_qty
                    print(f"  Total ALT Short Initialized: ${actual_alt_usd_value_total:,.2f}")
                else:
                    print("Warning: Total mcap_btc zero or NaN at init. No ALT shorts.")
                    alt_qty = {}
            
            # Store BTC position details
            if detailed_output:
                detailed_positions.append({
                    "Date": pd.Timestamp(t0),
                    "Symbol": "BTC",
                    "Type": "LONG",
                    "Weight": btc_w,
                    "Quantity": btc_qty,
                    "Price_BTC": 1.0,
                    "Price_USD": btc_price0,
                    "Value_USD": btc_qty * btc_price0,
                    "PnL_BTC": 0.0,
                    "PnL_USD": 0.0
                })
                
            rows.append({
                "Date": pd.Timestamp(t0),
                "Equity_USD": equity,
                "BTC_Price_USD": btc_price0,
                "BtcQty": btc_qty,
                "BtcHold_USD": btc_qty * btc_price0,
                "AltShortTarget_USD": alt_notional_usd_target,
                "AltShortActual_USD": actual_alt_usd_value_total,
                "AltShortCount": len(alt_qty),
                "Weekly_BTC_PNL_USD": 0.0,
                "Weekly_ALT_PNL_USD": 0.0,
                "Cum_BTC_PNL_USD": 0.0,
                "Cum_ALT_PNL_USD": 0.0,
                "Cum_ALT_PNL_BTC": 0.0,
                "Weekly_Return_Pct": 0.0
            })
            print("-" * 50)
            continue

        # Calculate P/L for this week
        print(f"--- Week {pd.Timestamp(t0).date()} -> {pd.Timestamp(t1).date()} ---")
        
        # Calculate BTC position P/L
        btc_pnl_usd = (btc_price1 - btc_price0) * btc_qty
        btc_return_pct = ((btc_price1 - btc_price0) / btc_price0) * 100
        print(f"  BTC: {btc_pnl_usd:+,.2f} USD ({btc_return_pct:+.2f}%) | Price: ${btc_price0:,.2f} -> ${btc_price1:,.2f}")
        
        # Store BTC position details
        if detailed_output:
            detailed_positions.append({
                "Date": pd.Timestamp(t1),
                "Symbol": "BTC",
                "Type": "LONG",
                "Weight": btc_w,
                "Quantity": btc_qty,
                "Price_BTC": 1.0,
                "Price_USD": btc_price1,
                "Value_USD": btc_qty * btc_price1,
                "PnL_BTC": 0.0,  # BTC doesn't have BTC-denominated P/L
                "PnL_USD": btc_pnl_usd
            })

        # Calculate ALT positions P/L
        print(f"  ALT Shorts Performance:")
        print(f"    {'Symbol':<6} {'PnL BTC':>12} {'PnL USD':>12} {'Price Change':>12} {'Entry->Exit':>20}")
        print(f"    {'-'*6:<6} {'-'*12:>12} {'-'*12:>12} {'-'*12:>12} {'-'*20:>20}")
        
        weekly_alt_pnl_btc = 0.0
        weekly_alt_pnl_usd = 0.0
        
        for sym, qty_held in alt_qty.items():
            if sym in w0.index and sym in w1.index:
                p0_btc = w0.at[sym, "price_btc"]
                p1_btc = w1.at[sym, "price_btc"]
                p0_usd = w0.at[sym, "price_usd"]
                p1_usd = w1.at[sym, "price_usd"]
                
                if not pd.isna(p0_btc) and not pd.isna(p1_btc):
                    # Calculate P/L in BTC and USD
                    pnl_btc = (p1_btc - p0_btc) * qty_held
                    pnl_usd = pnl_btc * btc_price1
                    weekly_alt_pnl_btc += pnl_btc
                    weekly_alt_pnl_usd += pnl_usd
                    
                    # Calculate percentage change (negative is good for shorts)
                    price_change_pct = ((p1_btc - p0_btc) / p0_btc) * 100
                    
                    # Print formatted row
                    print(f"    {sym:<6} {pnl_btc:>+12.6f} {pnl_usd:>+12.2f} {price_change_pct:>+11.2f}% {p0_btc:>9.8f}->{p1_btc:<9.8f}")
                    
                    # Store detailed position data
                    if detailed_output:
                        detailed_positions.append({
                            "Date": pd.Timestamp(t1),
                            "Symbol": sym,
                            "Type": "SHORT",
                            "Weight": 0.0,  # Will be calculated later based on portfolio
                            "Quantity": qty_held,
                            "Price_BTC": p1_btc,
                            "Price_USD": p1_usd,
                            "Value_USD": abs(qty_held * p1_btc * btc_price1),
                            "PnL_BTC": pnl_btc,
                            "PnL_USD": pnl_usd
                        })
                else:
                    print(f"    {sym:<6} {'N/A':>12} {'N/A':>12} {'N/A':>12} {'N/A':>20}  (price data missing)")

        # Summary of week's performance
        total_weekly_pnl = btc_pnl_usd + weekly_alt_pnl_usd
        weekly_return_pct = (total_weekly_pnl / equity) * 100
        
        print(f"\n  Week Summary:")
        print(f"    BTC P/L:     {btc_pnl_usd:+,.2f} USD")
        print(f"    ALT P/L:     {weekly_alt_pnl_usd:+,.2f} USD ({weekly_alt_pnl_btc:+.6f} BTC)")
        print(f"    Total P/L:   {total_weekly_pnl:+,.2f} USD ({weekly_return_pct:+.2f}%)")
        
        # Update running totals
        cum_btc_pnl += btc_pnl_usd
        cum_alt_pnl += weekly_alt_pnl_usd
        total_alt_pnl_btc += weekly_alt_pnl_btc
        equity += total_weekly_pnl
        
        print(f"    New Equity:  {equity:,.2f} USD")
        
        if equity <= 0 or pd.isna(equity):
            print("Equity invalid, stopping.")
            break

        # Rebalance for next week
        print(f"\n  Rebalancing Positions:")
        btc_qty_old = btc_qty  # For reporting change
        btc_qty = (btc_w * equity) / btc_price1
        btc_change_pct = ((btc_qty - btc_qty_old) / btc_qty_old) * 100 if btc_qty_old != 0 else 0
        print(f"    BTC Long: {btc_qty_old:.6f} -> {btc_qty:.6f} ({btc_change_pct:+.2f}%) | Value: ${btc_qty * btc_price1:,.2f}")
        
        # Rebalance ALT shorts
        alt_notional_usd_target = alt_w * equity
        alts_df_t1 = w1[~w1.index.isin(excluded)].nsmallest(top_n, "rank")
        new_alt_qty: dict[str, float] = {}
        actual_alt_usd_value_total = 0.0
        
        if not alts_df_t1.empty:
            tot_mcap = alts_df_t1["mcap_btc"].sum()
            if tot_mcap > 0 and not pd.isna(tot_mcap):
                # Check for changes in the basket composition
                old_symbols = set(alt_qty.keys())
                new_symbols = set(alts_df_t1.index)
                added = new_symbols - old_symbols
                removed = old_symbols - new_symbols
                
                if added:
                    print(f"    Added to basket: {', '.join(sorted(added))}")
                if removed:
                    print(f"    Removed from basket: {', '.join(sorted(removed))}")
                
                # Calculate new quantities
                for sym, r in alts_df_t1.iterrows():
                    if not pd.isna(r.price_btc) and r.price_btc != 0 and not pd.isna(r.mcap_btc):
                        alt_usd_target_sym = alt_notional_usd_target * (r.mcap_btc / tot_mcap)
                        qty = -(alt_usd_target_sym / (r.price_btc * btc_price1))
                        new_alt_qty[sym] = qty
                        actual_alt_usd_value_total += abs(qty * r.price_btc * btc_price1)
                
            alt_qty = new_alt_qty

        # Save performance metrics for this week
        rows.append({
            "Date": pd.Timestamp(t1),
            "Equity_USD": equity,
            "BTC_Price_USD": btc_price1,
            "BtcQty": btc_qty,
            "BtcHold_USD": btc_qty * btc_price1,
            "AltShortTarget_USD": alt_notional_usd_target,
            "AltShortActual_USD": actual_alt_usd_value_total,
            "AltShortCount": len(alt_qty),
            "Weekly_BTC_PNL_USD": btc_pnl_usd,
            "Weekly_ALT_PNL_USD": weekly_alt_pnl_usd,
            "Cum_BTC_PNL_USD": cum_btc_pnl,
            "Cum_ALT_PNL_USD": cum_alt_pnl,
            "Cum_ALT_PNL_BTC": total_alt_pnl_btc,
            "Weekly_Return_Pct": weekly_return_pct
        })
        print("-" * 50)

    print("\n--- Backtest End ---")
    perf_df = pd.DataFrame(rows)
    
    # Create detailed positions DataFrame
    detailed_df = pd.DataFrame(detailed_positions) if detailed_positions else pd.DataFrame()
    
    # Calculate final equity and BTC equivalent
    final_btc_price = perf_df.iloc[-1]["BTC_Price_USD"] if not perf_df.empty and "BTC_Price_USD" in perf_df.columns else 0
    btc_equiv = equity / final_btc_price if final_btc_price and final_btc_price != 0 else 0
    
    # Calculate summary statistics
    total_return_pct = ((equity - start_cap) / start_cap) * 100
    weekly_returns = perf_df["Weekly_Return_Pct"].dropna().values if not perf_df.empty else []
    annualized_return = total_return_pct * (52 / len(weekly_returns)) if weekly_returns.size > 0 else 0
    max_drawdown = calculate_max_drawdown(perf_df) if not perf_df.empty else 0
    
    # Assemble summary dictionary
    summary = {
        "cum_btc_pnl": cum_btc_pnl,
        "cum_alt_pnl": cum_alt_pnl,
        "cum_alt_pnl_btc": total_alt_pnl_btc,
        "final_equity": equity,
        "btc_equiv": btc_equiv,
        "total_return_pct": total_return_pct,
        "annualized_return": annualized_return,
        "max_drawdown": max_drawdown,
        "sharpe_ratio": calculate_sharpe_ratio(weekly_returns) if weekly_returns.size > 0 else 0,
        "sortino_ratio": calculate_sortino_ratio(weekly_returns) if weekly_returns.size > 0 else 0,
        "win_rate": np.mean(weekly_returns > 0) * 100 if weekly_returns.size > 0 else 0,
    }
    
    return perf_df, summary, detailed_df


def calculate_max_drawdown(perf_df: pd.DataFrame) -> float:
    """Calculate maximum drawdown from equity curve."""
    if "Equity_USD" not in perf_df.columns or perf_df.empty:
        return 0.0
    
    equity = perf_df["Equity_USD"].values
    peak = np.maximum.accumulate(equity)
    drawdown = (equity - peak) / peak
    return abs(min(drawdown)) * 100  # Convert to percentage


def calculate_sharpe_ratio(returns: np.ndarray, risk_free_rate: float = 0.02) -> float:
    """Calculate annualized Sharpe ratio from weekly returns."""
    if returns.size == 0:
        return 0.0
    
    # Convert weekly returns to annualized values
    annualized_return = np.mean(returns) * 52
    annualized_volatility = np.std(returns) * np.sqrt(52)
    
    if annualized_volatility == 0:
        return 0.0
        
    return (annualized_return - risk_free_rate) / annualized_volatility


def calculate_sortino_ratio(returns: np.ndarray, risk_free_rate: float = 0.02) -> float:
    """Calculate annualized Sortino ratio from weekly returns."""
    if returns.size == 0:
        return 0.0
    
    # Calculate downside deviation (only negative returns)
    negative_returns = returns[returns < 0]
    
    if negative_returns.size == 0:
        return np.inf  # No negative returns means infinite Sortino ratio
    
    downside_deviation = np.std(negative_returns) * np.sqrt(52)
    
    if downside_deviation == 0:
        return 0.0
        
    annualized_return = np.mean(returns) * 52
    return (annualized_return - risk_free_rate) / downside_deviation


def plot_equity_curve(perf_df: pd.DataFrame, summary: dict, start_date: dt.datetime, end_date: dt.datetime) -> plt.Figure:
    """Plot equity curve with drawdowns and key metrics."""
    if not perf_df.empty and "Equity_USD" in perf_df.columns:
        plot_data = perf_df.dropna(subset=["Equity_USD", "Date"])
        if not plot_data.empty:
            # Create subplots: equity curve and weekly returns
            fig, (ax1, ax2) = plt.subplots(2, 1, figsize=(12, 10), 
                                           gridspec_kw={'height_ratios': [3, 1]})
            
            # --- Equity Curve (Top Plot) ---
            ymin = min(START_CAP, plot_data["Equity_USD"].min()) * 0.9
            ymax = max(START_CAP, plot_data["Equity_USD"].max()) * 1.1
            ymin = max(0, ymin)
            if ymin >= ymax:
                ymax = ymin * 1.2 if ymin > 0 else START_CAP * 1.1
                
            fmt = ScalarFormatter(useOffset=False)
            fmt.set_scientific(False)
            
            # Plot equity curve
            ax1.plot(plot_data["Date"], plot_data["Equity_USD"], marker=".", linestyle="-", 
                    color='blue', linewidth=2, label="Portfolio Value")
            
            # Plot BTC buy-and-hold for comparison
            if "BTC_Price_USD" in plot_data.columns:
                initial_btc_price = plot_data["BTC_Price_USD"].iloc[0]
                btc_qty = START_CAP / initial_btc_price
                btc_value = plot_data["BTC_Price_USD"] * btc_qty
                ax1.plot(plot_data["Date"], btc_value, marker="", linestyle="--", 
                        color='orange', linewidth=1.5, label="BTC Buy & Hold")
            
            title = f"{BTC_W*100:.0f}% BTC long vs {ALT_W*100:.0f}% ALT short (Top {TOP_N})"
            date_range = f"[{start_date.date()} to {end_date.date()}]"
            ax1.set_title(f"{title}\n{date_range}", fontsize=14)
            
            ax1.set_xlabel("")  # We'll put the label on the bottom plot
            ax1.set_ylabel("Equity (USD)", fontsize=12)
            ax1.set_ylim(ymin, ymax)
            ax1.grid(True, which="major", linestyle="--", alpha=0.7)
            ax1.grid(True, which="minor", linestyle=":", alpha=0.5)
            ax1.minorticks_on()
            ax1.yaxis.set_major_formatter(fmt)
            ax1.axhline(START_CAP, color="red", linestyle="--", linewidth=1, 
                       label=f"Initial Capital (${START_CAP:,.0f})")
            
            # Calculate drawdown for shading
            equity = plot_data["Equity_USD"].values
            dates = plot_data["Date"].values
            peak = np.maximum.accumulate(equity)
            drawdown = (equity - peak) / peak
            
            # Color the background based on drawdown severity
            for i in range(1, len(drawdown)):
                if drawdown[i] < -0.05:  # More than 5% drawdown
                    color = 'salmon'
                    alpha = min(0.3, abs(drawdown[i]))
                    ax1.axvspan(dates[i-1], dates[i], color=color, alpha=alpha)
            
            # Add key metrics as text box
            metrics_text = (
                f"Total Return: {summary['total_return_pct']:.2f}%\n"
                f"Annualized: {summary['annualized_return']:.2f}%\n"
                f"Max Drawdown: {summary['max_drawdown']:.2f}%\n"
                f"Sharpe Ratio: {summary['sharpe_ratio']:.2f}\n"
                f"Win Rate: {summary['win_rate']:.1f}%"
            )
            ax1.text(0.02, 0.02, metrics_text, transform=ax1.transAxes, fontsize=10,
                   bbox=dict(boxstyle="round,pad=0.3", fc="wheat", alpha=0.7))
            
            ax1.legend(loc='upper left')
            
            # --- Weekly Returns (Bottom Plot) ---
            if "Weekly_Return_Pct" in plot_data.columns:
                returns = plot_data["Weekly_Return_Pct"]
                
                # Create bar plot of weekly returns
                colors = ['green' if r >= 0 else 'red' for r in returns]
                ax2.bar(plot_data["Date"], returns, color=colors, alpha=0.7, width=6)
                
                ax2.axhline(0, color='black', linestyle='-', linewidth=0.5)
                ax2.set_xlabel("Date", fontsize=12)
                ax2.set_ylabel("Weekly Return (%)", fontsize=12)
                ax2.yaxis.set_major_formatter(PercentFormatter())
                ax2.grid(True, axis='y', linestyle='--', alpha=0.5)
                
                # Set date formatting to match the top plot
                fig.autofmt_xdate()
            
            plt.tight_layout()
            return fig
        
    # Return None if we couldn't create a plot
    return None


def plot_btc_vs_alts(perf_df: pd.DataFrame) -> plt.Figure:
    """Plot separate performance of BTC long vs ALT short legs."""
    if not perf_df.empty and all(col in perf_df.columns for col in ["Cum_BTC_PNL_USD", "Cum_ALT_PNL_USD", "Date"]):
        # Create figure
        fig, ax = plt.subplots(figsize=(12, 6))
        
        # Plot cumulative P/L for each leg
        ax.plot(perf_df["Date"], perf_df["Cum_BTC_PNL_USD"], 
                marker="", linestyle="-", color='blue', linewidth=2, 
                label="BTC Long Cumulative P/L")
        
        ax.plot(perf_df["Date"], perf_df["Cum_ALT_PNL_USD"], 
                marker="", linestyle="-", color='red', linewidth=2, 
                label="ALT Short Cumulative P/L")
        
        # Plot total P/L
        total_pnl = perf_df["Cum_BTC_PNL_USD"] + perf_df["Cum_ALT_PNL_USD"]
        ax.plot(perf_df["Date"], total_pnl, 
                marker="", linestyle="-", color='green', linewidth=2, 
                label="Total Cumulative P/L")
        
        # Style the plot
        ax.set_title("BTC Long vs ALT Short - Cumulative P/L Contribution", fontsize=14)
        ax.set_xlabel("Date", fontsize=12)
        ax.set_ylabel("Cumulative P/L (USD)", fontsize=12)
        
        # Add zero line
        ax.axhline(0, color='black', linestyle='-', linewidth=0.5)
        
        # Add grid and legend
        ax.grid(True, linestyle='--', alpha=0.7)
        ax.legend(loc='best')
        
        # Format dates on x-axis
        fig.autofmt_xdate()
        plt.tight_layout()
        
        return fig
    
    return None


def export_detailed_report(perf_df: pd.DataFrame, summary: dict, detailed_df: pd.DataFrame, 
                           start_date: dt.datetime, end_date: dt.datetime):
    """Export detailed backtest report to CSV files and plots."""
    # Create reports directory if it doesn't exist
    REPORTS_DIR.mkdir(exist_ok=True)
    
    # Generate timestamp for unique filenames
    timestamp = dt.datetime.now().strftime("%Y%m%d_%H%M%S")
    
    # Export performance dataframe
    if not perf_df.empty:
        perf_file = REPORTS_DIR / f"performance_{timestamp}.csv"
        perf_df.to_csv(perf_file, index=False)
        print(f"Exported performance data to {perf_file}")
    
    # Export detailed positions dataframe
    if not detailed_df.empty:
        detail_file = REPORTS_DIR / f"positions_{timestamp}.csv"
        detailed_df.to_csv(detail_file, index=False)
        print(f"Exported detailed position data to {detail_file}")
    
    # Export summary as text file
    summary_file = REPORTS_DIR / f"summary_{timestamp}.txt"
    with open(summary_file, "w") as f:
        f.write(f"Backtest Summary: {start_date.date()} to {end_date.date()}\n")
        f.write(f"Strategy: {BTC_W*100:.0f}% BTC long vs {ALT_W*100:.0f}% ALT short (Top {TOP_N})\n\n")
        
        f.write("Performance Metrics:\n")
        f.write(f"Initial Capital: ${START_CAP:,.2f}\n")
        f.write(f"Final Equity: ${summary['final_equity']:,.2f}\n")
        f.write(f"Total Return: {summary['total_return_pct']:+.2f}%\n")
        f.write(f"Annualized Return: {summary['annualized_return']:+.2f}%\n")
        f.write(f"Maximum Drawdown: {summary['max_drawdown']:.2f}%\n")
        f.write(f"Sharpe Ratio: {summary['sharpe_ratio']:.2f}\n")
        f.write(f"Sortino Ratio: {summary['sortino_ratio']:.2f}\n")
        f.write(f"Win Rate: {summary['win_rate']:.1f}%\n\n")
        
        f.write("Contribution Analysis:\n")
        f.write(f"BTC Long P/L: ${summary['cum_btc_pnl']:+,.2f}\n")
        f.write(f"ALT Short P/L: ${summary['cum_alt_pnl']:+,.2f} ({summary['cum_alt_pnl_btc']:+.6f} BTC)\n")
        f.write(f"BTC Equivalent Value: {summary['btc_equiv']:.6f} BTC\n")
    
    print(f"Exported summary to {summary_file}")
    
    # Save plots
    equity_fig = plot_equity_curve(perf_df, summary, start_date, end_date)
    if equity_fig:
        equity_plot_file = REPORTS_DIR / f"equity_curve_{timestamp}.png"
        equity_fig.savefig(equity_plot_file, dpi=300, bbox_inches="tight")
        print(f"Exported equity curve plot to {equity_plot_file}")
    
    contribution_fig = plot_btc_vs_alts(perf_df)
    if contribution_fig:
        contrib_plot_file = REPORTS_DIR / f"contribution_{timestamp}.png"
        contribution_fig.savefig(contrib_plot_file, dpi=300, bbox_inches="tight")
        print(f"Exported contribution plot to {contrib_plot_file}")


def main():
    if not CSV_PATH.exists():
        print(f"CSV not found: {CSV_PATH}")
        return
        
    print(f"Loading data from {CSV_PATH}")
    print(f"Date range: {START_DATE.date()} to {END_DATE.date()}")
    
    df = load_and_prepare(CSV_PATH, START_DATE, END_DATE)
    print(f"Loaded {len(df)} rows over {df['rebalance_ts'].nunique()} weeks")
    
    # Run backtest
    perf, summary, detailed = backtest_rank_altbtc_short(df)
    
    # Display summary
    if summary:
        print("\n--- Summary ---")
        print(f"Cumulative BTC P/L : {summary['cum_btc_pnl']:+,.2f} USD")
        print(f"Cumulative ALT P/L : {summary['cum_alt_pnl']:+,.2f} USD ({summary['cum_alt_pnl_btc']:+.6f} BTC)")
        print(f"Final equity       : {summary['final_equity']:,.2f} USD")
        print(f"Total return       : {summary['total_return_pct']:+.2f}%")
        print(f"Annualized return  : {summary['annualized_return']:+.2f}%")
        print(f"Maximum drawdown   : {summary['max_drawdown']:.2f}%")
        print(f"Sharpe ratio       : {summary['sharpe_ratio']:.2f}")
        print(f"Win rate           : {summary['win_rate']:.1f}%")
        print(f"Final BTC equiv    : {summary['btc_equiv']:.6f} BTC")
        
        # Export detailed report
        export_detailed_report(perf, summary, detailed, START_DATE, END_DATE)
        
        # Show plots
        equity_fig = plot_equity_curve(perf, summary, START_DATE, END_DATE)
        if equity_fig:
            plt.figure(equity_fig.number)
            plt.show()
        
        contribution_fig = plot_btc_vs_alts(perf)
        if contribution_fig:
            plt.figure(contribution_fig.number)
            plt.show()
    else:
        print("Backtest did not produce a summary.")


if __name__ == "__main__":
    main()