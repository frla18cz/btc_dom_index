#!/usr/bin/env python3
"""
Analyzer for BTC long vs ALT short backtest using weekly top-100 snapshots.
Data source: top100_weekly_data.csv (generated by fetcher.py).
"""
from pathlib import Path
import pandas as pd
import matplotlib.pyplot as plt
from matplotlib.ticker import ScalarFormatter, PercentFormatter
import datetime as dt
import numpy as np
from tabulate import tabulate
import textwrap

# Import configuration
from config.config import (
    EXCLUDED_SYMBOLS,
    BACKTEST_START_DATE,
    BACKTEST_END_DATE,
    BACKTEST_INITIAL_CAPITAL,
    BACKTEST_BTC_WEIGHT,
    BACKTEST_ALT_WEIGHT,
    BACKTEST_TOP_N_ALTS
)

# Configuration with defaults from config.py
CSV_PATH = Path("top100_weekly_data.csv")
START_CAP = BACKTEST_INITIAL_CAPITAL
BTC_W = BACKTEST_BTC_WEIGHT
ALT_W = BACKTEST_ALT_WEIGHT
TOP_N = BACKTEST_TOP_N_ALTS
EXCLUDED = EXCLUDED_SYMBOLS
# Date range for backtesting
START_DATE = BACKTEST_START_DATE
END_DATE = BACKTEST_END_DATE
# Output directory for detailed reports
REPORTS_DIR = Path("reports")
# Overwrite all reports on each run
OVERWRITE_REPORTS = True


def load_and_prepare(csv_path: Path, start_date=None, end_date=None) -> pd.DataFrame:
    """
    Load CSV from csv_path, clean numeric columns, compute price_btc and mcap_btc columns.
    Optionally filters data by date range.
    
    Args:
        csv_path: Path to the CSV file
        start_date: Optional start date to filter data (inclusive)
        end_date: Optional end date to filter data (inclusive)
        
    Returns:
        DataFrame compatible with backtest_rank_altbtc_short.
    """
    df = pd.read_csv(csv_path)
    # parse date
    df["snapshot_date"] = pd.to_datetime(df["snapshot_date"])
    
    # Filter by date range if provided
    if start_date:
        df = df[df["snapshot_date"] >= pd.Timestamp(start_date)]
    if end_date:
        df = df[df["snapshot_date"] <= pd.Timestamp(end_date)]
        
    # rename to match old analyzer expectations
    df = df.rename(
        columns={
            "snapshot_date": "rebalance_ts",
            "symbol": "sym",
            "price": "price_usd",
            "market_cap": "market_cap_usd",
        }
    )
    # clean numeric columns
    for col in ["price_usd", "market_cap_usd", "volume_24h"]:
        if col in df.columns:
            df[col] = (
                df[col]
                .astype(str)
                .replace(r"[\$,]", "", regex=True)
                .astype(float)
            )
    # map BTC price per week
    btc_prices = (
        df.loc[df["sym"] == "BTC", ["rebalance_ts", "price_usd"]]
        .drop_duplicates()
        .set_index("rebalance_ts")["price_usd"]
    )
    # assign btc_price_usd
    df["btc_price_usd"] = df["rebalance_ts"].map(btc_prices)
    # compute price_btc and mcap_btc
    df["price_btc"] = df["price_usd"] / df["btc_price_usd"]
    df["mcap_btc"] = df["market_cap_usd"] / df["btc_price_usd"]
    # ensure rank integer
    df["rank"] = df["rank"].astype(int)
    # drop rows lacking key data
    df = df.dropna(subset=["rebalance_ts", "sym", "btc_price_usd", "price_usd", "price_btc", "mcap_btc", "rank"])
    return df


def print_section(title, width=80):
    """Print a formatted section header."""
    print("\n" + "-" * width)
    print(f"{title:^{width}}")
    print("-" * width)


def print_alt_portfolio_table(alt_data, weights, values, title):
    """Format and print alt portfolio table with weights."""
    print_section(title)
    
    if not alt_data:
        print("No altcoins in portfolio")
        return
    
    # Prepare the table data
    table_data = []
    total_weight = sum(weights.values()) if weights else 0
    total_value = sum(values.values()) if values else 0
    
    for sym, data in alt_data.items():
        weight = weights.get(sym, 0)
        weight_pct = (weight / total_weight * 100) if total_weight > 0 else 0
        value = values.get(sym, 0)
        value_pct = (value / total_value * 100) if total_value > 0 else 0
        
        # Ensure the 'rank' value is a number not a method
        rank = data.get('rank', 'N/A')
        if callable(rank):
            rank = int(data.get('rank_int', 0))
        
        row = [
            sym,  # Symbol
            rank,  # Rank
            data.get('price_usd', 0),  # Price in USD
            value,  # Position Value USD
            value_pct,  # % of Portfolio
            weight_pct,  # Weight %
            data.get('qty', 0),  # Quantity
            data.get('price_btc', 0),  # Price in BTC
        ]
        table_data.append(row)
    
    # Sort by weight percentage (descending)
    table_data.sort(key=lambda x: x[5], reverse=True)
    
    # Add totals row
    table_data.append([
        "TOTAL", "", "", 
        total_value, 100.0, 100.0, "", ""
    ])
    
    headers = ["Symbol", "Rank", "Price USD", "Value USD", "% of Port", 
               "Weight %", "Quantity", "Price BTC"]
    
    # Simplified formatting
    print(tabulate(table_data, headers=headers, tablefmt="grid", 
                  floatfmt=[".2f", ".0f", ".2f", ".2f", ".2f", ".2f", ".4f", ".8f"],
                  numalign="right"))


def backtest_rank_altbtc_short(df: pd.DataFrame,
                              btc_w: float = BTC_W,
                              alt_w: float = ALT_W,
                              top_n: int = TOP_N,
                              excluded: list = None,
                              start_cap: float = START_CAP,
                              detailed_output: bool = True) -> tuple[pd.DataFrame, dict, pd.DataFrame]:
    """
    Backtest the BTC long vs ALT short strategy.
    
    Args:
        df: DataFrame with prepared cryptocurrency data
        btc_w: Weight of BTC position (0-1)
        alt_w: Weight of ALT position (0-1)
        top_n: Number of top altcoins to include in the short basket
        excluded: List of symbols to exclude from the short basket
        start_cap: Initial capital in USD
        detailed_output: Whether to save detailed weekly position data
        
    Returns:
        Tuple of (performance DataFrame, summary dictionary, detailed_positions DataFrame)
    """
    if excluded is None:
        excluded = EXCLUDED
        
    weeks = sorted(df["rebalance_ts"].unique())
    if len(weeks) < 2:
        print("Not enough weeks for backtest")
        return pd.DataFrame(), {}, pd.DataFrame()
        
    equity = start_cap

    # Position tracking
    btc_qty = 0.0                  # BTC position in coins
    alt_coin_quantities = {}       # Symbol -> actual coin quantities (negative for shorts)
    alt_notional_values = {}       # Symbol -> notional USD size of position
    alt_weights = {}               # Symbol -> target weight within ALT basket
    alt_values = {}                # Symbol -> absolute USD value
    
    # Performance tracking
    rows = []
    detailed_positions = []
    cum_btc_pnl = cum_alt_pnl = 0.0
    
    # Calculate total leverage
    total_leverage = btc_w + alt_w
    print(f"\n========== BACKTEST: {btc_w*100:.1f}% BTC + {alt_w*100:.1f}% ALT Short (Top {top_n}) ==========")
    print(f"Date Range: {pd.Timestamp(weeks[0]).date()} to {pd.Timestamp(weeks[-1]).date()}")
    print(f"Total Leverage: {total_leverage:.2f}x")
    print(f"Excluded Tokens: {', '.join(sorted(excluded))}")
    print(f"Initial Capital: ${start_cap:,.2f} USD")

    # ===== INITIALIZATION =====
    # Set up initial positions for week 0 to 1
    print("\n\n")
    print("┏" + "━" * 80 + "┓")
    print(f"┃{'INITIAL PORTFOLIO SETUP':^80}┃")
    print("┗" + "━" * 80 + "┛")
    
    # Get data frames for first week (t0) and second week (t1)
    t0, t1 = weeks[0], weeks[1]
    w0 = df[df.rebalance_ts == t0].set_index('sym')
    
    # Check if we have BTC price for the first week
    try:
        btc_price0 = w0.loc["BTC", "price_usd"]
        if pd.isna(btc_price0) or btc_price0 == 0:
            raise ValueError("BTC price is NaN or zero")
    except Exception as e:
        print(f"Error getting initial BTC price: {e}")
        print("Cannot initialize positions without BTC price.")
        return pd.DataFrame(), {}, pd.DataFrame()
    
    # 1. Calculate initial BTC position
    btc_qty = (btc_w * equity) / btc_price0
    btc_value = btc_qty * btc_price0
    
    print("\n┌─────────────────────────────────────────────────────────────────────────────┐")
    print(f"│                         INITIAL BTC LONG POSITION                            │")
    print("├─────────────────────────────────────────────────────────────────────────────┤")
    print(f"│ SETUP FOR WEEK 1 ({pd.Timestamp(t0).strftime('%Y-%m-%d')}):                                         │")
    print(f"│   BTC Price:            ${btc_price0:15,.2f} USD                                │")
    print(f"│   BTC Quantity:         {btc_qty:15.6f} BTC   (Weight: {btc_w*100:.1f}%)           │")
    print(f"│   BTC Position Value:   ${btc_value:15,.2f} USD                                │")
    print("└─────────────────────────────────────────────────────────────────────────────┘")
    
    # Store BTC position details
    if detailed_output:
        detailed_positions.append({
            "Date": pd.Timestamp(t0),
            "Symbol": "BTC",
            "Type": "LONG",
            "Weight": btc_w,
            "Quantity": btc_qty,
            "Price_USD": btc_price0,
            "Value_USD": btc_value,
            "PnL_USD": 0.0
        })
    
    # 2. Calculate initial ALT short positions
    # Target value for all short positions combined
    alt_notional_usd_target = alt_w * equity
    
    # Apply excluded symbols filter 
    filtered_w0 = w0[~w0.index.isin(excluded)]
    if "BTC" in filtered_w0.index:
        print(f"WARNING: BTC found in filtered dataframe, removing it")
        filtered_w0 = filtered_w0.drop("BTC", errors="ignore")
        
    # Select top_n altcoins by rank
    alts_df_t0 = filtered_w0.nsmallest(top_n, "rank") if not filtered_w0.empty else filtered_w0
    
    print("\n┌─────────────────────────────────────────────────────────────────────────────┐")
    print(f"│                         INITIAL ALT SHORT POSITIONS                          │")
    print("├─────────────────────────────────────────────────────────────────────────────┤")
    print(f"│ SETUP FOR WEEK 1 ({pd.Timestamp(t0).strftime('%Y-%m-%d')}):                                         │")
    print(f"│   Target Weight:        {alt_w*100:.1f}% of portfolio                              │")
    print(f"│   Target Value:         ${alt_notional_usd_target:15,.2f} USD                                │")
    print(f"│   Number of ALTs:       {top_n:15d}                                         │")
    print("└─────────────────────────────────────────────────────────────────────────────┘")
    
    if not alts_df_t0.empty:
        # Calculate weights based on market cap
        tot_mcap = alts_df_t0["mcap_btc"].sum()
        
        if tot_mcap > 0 and not pd.isna(tot_mcap):
            alt_data = {}  # For tabular display
            
            for sym, r in alts_df_t0.iterrows():
                if pd.isna(r.price_usd) or r.price_usd == 0:
                    continue
                    
                # Calculate weight proportional to market cap
                weight = r.mcap_btc / tot_mcap
                alt_weights[sym] = weight
                
                # Calculate target USD value for this altcoin
                target_usd_value = alt_notional_usd_target * weight
                
                # Calculate negative quantity (short position)
                # IMPORTANT: We use t0 prices to calculate quantities for week 1
                coin_qty = -target_usd_value / r.price_usd
                alt_coin_quantities[sym] = coin_qty
                
                # Store notional USD value (negative for shorts)
                alt_notional_values[sym] = -target_usd_value
                
                # Store position USD value (absolute value)
                alt_values[sym] = abs(alt_notional_values[sym])
                
                # Store data for display
                alt_data[sym] = {
                    'rank': r.rank,
                    'qty': coin_qty,  # Negative quantity for short
                    'price_usd': r.price_usd,
                    'price_btc': r.price_btc,
                    'mcap_btc': r.mcap_btc,
                    'target_usd': target_usd_value,
                    'actual_usd': alt_values[sym],
                    'weight': weight
                }
                
                # Store detailed position data
                if detailed_output:
                    detailed_positions.append({
                        "Date": pd.Timestamp(t0),
                        "Symbol": sym,
                        "Type": "SHORT",
                        "Weight": weight,
                        "Quantity": coin_qty,
                        "Price_USD": r.price_usd,
                        "Value_USD": abs(alt_notional_values[sym]),
                        "PnL_USD": 0.0
                    })
            
            # Print the ALT positions table
            print_alt_portfolio_table(alt_data, alt_weights, alt_values, "ALT SHORT BASKET COMPOSITION")
        else:
            print("No valid market cap data for ALTs. Cannot initialize short positions.")
    else:
        print("No ALTs available after filtering. No short positions initialized.")

    # ===== MAIN BACKTEST LOOP =====
    for i in range(len(weeks) - 1):
        # Get data for current week (t0) and next week (t1)
        t0, t1 = weeks[i], weeks[i + 1]
        w0 = df[df.rebalance_ts == t0].set_index('sym')
        w1 = df[df.rebalance_ts == t1].set_index('sym')
        
        # Weekly header
        week_header = f"WEEK {i+1}: {pd.Timestamp(t0).strftime('%Y-%m-%d')} → {pd.Timestamp(t1).strftime('%Y-%m-%d')}"
        print("\n\n")
        print("┏" + "━" * 80 + "┓")
        print(f"┃{week_header:^80}┃")
        print("┗" + "━" * 80 + "┛")
        print("\n")

        # Get BTC prices for this period
        try:
            btc_price0 = w0.loc["BTC", "price_usd"]
            btc_price1 = w1.loc["BTC", "price_usd"]
            if pd.isna(btc_price0) or pd.isna(btc_price1) or btc_price0 == 0:
                raise ValueError("BTC price is NaN or zero")
        except Exception as e:
            print(f"Error getting BTC price: {e}")
            if i == 0:
                print("Cannot analyze first week without BTC price.")
                return pd.DataFrame(), {}, pd.DataFrame()
            else:
                print("Using previous BTC price due to missing data.")
                continue

        # ===== 1. DISPLAY PORTFOLIO AT START OF WEEK =====
        # Show positions that were established at the end of previous week
        print("\n┌─────────────────────────────────────────────────────────────────────────────┐")
        print(f"│                    PORTFOLIO POSITIONS - WEEK {i+1} START                     │")
        print("├─────────────────────────────────────────────────────────────────────────────┤")
        print(f"│ DATE:                  {pd.Timestamp(t0).strftime('%Y-%m-%d')}                                           │")
        print(f"│                                                                             │")
        print(f"│ BTC position:          {btc_qty:15.6f} BTC @ ${btc_price0:,.2f} = ${btc_qty * btc_price0:,.2f}     │")
        
        alt_total_value = sum(abs(v) for v in alt_notional_values.values())
        print(f"│ ALT positions:         {len(alt_coin_quantities):15d} coins, total value: ${alt_total_value:,.2f}      │")
        print(f"│ Total equity:          ${equity:15,.2f} USD                                  │")
        print("└─────────────────────────────────────────────────────────────────────────────┘")
        
        # ===== 2. CALCULATE P&L FOR THIS WEEK =====
        
        # 2.1 Calculate BTC P&L
        btc_pnl_usd = btc_qty * (btc_price1 - btc_price0)
        btc_return_pct = ((btc_price1 - btc_price0) / btc_price0) * 100
        
        print("\n┌─────────────────────────────────────────────────────────────────────────────┐")
        print(f"│                       BTC LONG POSITION - PERFORMANCE                        │")
        print("├─────────────────────────────────────────────────────────────────────────────┤")
        print(f"│ WEEK {i+1} START ({pd.Timestamp(t0).strftime('%Y-%m-%d')}):                                                │")
        print(f"│   BTC Price:            ${btc_price0:15,.2f} USD                                │")
        print(f"│   BTC Quantity:         {btc_qty:15.6f} BTC                                  │")
        print(f"│   Position Value:       ${btc_qty * btc_price0:15,.2f} USD                                │")
        print("├─────────────────────────────────────────────────────────────────────────────┤")
        print(f"│ WEEK {i+1} END ({pd.Timestamp(t1).strftime('%Y-%m-%d')}):                                                  │")
        print(f"│   BTC Price:            ${btc_price1:15,.2f} USD                                │")
        print(f"│   Price Change:                               {btc_return_pct:+7.2f}%                   │")
        print(f"│   BTC Quantity:         {btc_qty:15.6f} BTC     (unchanged during week)      │")
        print(f"│   Position Value:       ${btc_qty * btc_price1:15,.2f} USD                                │")
        print("├─────────────────────────────────────────────────────────────────────────────┤")
        print(f"│ BTC POSITION RESULT:                                                         │")
        print(f"│   Weekly P&L:           ${btc_pnl_usd:+15,.2f} USD                                │")
        print("└─────────────────────────────────────────────────────────────────────────────┘")
        
        # Store BTC position details at end of week
        if detailed_output:
            detailed_positions.append({
                "Date": pd.Timestamp(t1),
                "Symbol": "BTC",
                "Type": "LONG",
                "Weight": btc_w,
                "Quantity": btc_qty,
                "Price_USD": btc_price1,
                "Value_USD": btc_qty * btc_price1,
                "PnL_USD": btc_pnl_usd
            })
        
        # 2.2 Calculate ALT P&L - for shorts using fixed coin quantities
        print("\n┌─────────────────────────────────────────────────────────────────────────────┐")
        print(f"│                      ALT SHORT POSITIONS - PERFORMANCE                       │")
        print("└─────────────────────────────────────────────────────────────────────────────┘")
        
        if not alt_coin_quantities:
            print("No ALT positions to track.")
            weekly_alt_pnl_usd = 0
            current_alt_values = {}
        else:
            # Prepare data for table display
            alt_pnl_data = []
            weekly_alt_pnl_usd = 0.0
            current_alt_values = {}
            
            for sym, coin_qty in alt_coin_quantities.items():
                if sym in w0.index and sym in w1.index:
                    # Get prices for this period
                    start_price = w0.at[sym, "price_usd"]
                    end_price = w1.at[sym, "price_usd"]
                    rank = w1.at[sym, "rank"]
                    
                    # For shorts: profit when price goes down, loss when price goes up
                    
                    # P&L calculation for this period
                    # For a short position (coin_qty is negative): profit when price decreases
                    pnl_usd = (start_price - end_price) * abs(coin_qty)
                    weekly_alt_pnl_usd += pnl_usd
                    
                    # Update position value at current prices (mark to market)
                    market_value = abs(coin_qty * end_price)
                    current_alt_values[sym] = market_value
                    
                    # Calculate percentage change in price
                    price_change_pct = ((end_price - start_price) / start_price) * 100
                    
                    # Add to data for table display
                    alt_pnl_data.append([
                        sym,                    # Symbol
                        rank,                   # Rank
                        start_price,            # Start Price
                        end_price,              # End Price
                        price_change_pct,       # Price Change %
                        coin_qty,               # Equivalent Coin Quantity
                        market_value,           # Position Value (USD)
                        market_value / sum(current_alt_values.values()) * 100 if sum(current_alt_values.values()) > 0 else 0,  # % of Basket
                        pnl_usd,                # P&L (USD)
                        alt_weights.get(sym, 0) * 100  # Target Weight %
                    ])
                    
                    # Store detailed position data at end of week
                    if detailed_output:
                        detailed_positions.append({
                            "Date": pd.Timestamp(t1),
                            "Symbol": sym,
                            "Type": "SHORT",
                            "Weight": alt_weights.get(sym, 0),
                            "Quantity": coin_qty,
                            "Price_USD": end_price,
                            "Value_USD": market_value,
                            "PnL_USD": pnl_usd
                        })
            
            if alt_pnl_data:
                # Sort by position value (descending)
                alt_pnl_data.sort(key=lambda x: x[6] if isinstance(x[6], (int, float)) else 0, reverse=True)
                
                # Add totals row
                total_value = sum(current_alt_values.values())
                alt_pnl_data.append([
                    "TOTAL", "", "", "", "", 
                    "",  # Quantity
                    total_value,  # Position Value
                    100.0,  # % of Basket
                    weekly_alt_pnl_usd,  # P&L (USD)
                    100.0  # Target Weight%
                ])
                
                # Print table
                headers = [
                    "Symbol", "Rank", "Start Price", "End Price", "Change%", 
                    "Coins Qty", "Position USD", "% of Basket", "P&L (USD)", "Target Weight%"
                ]
                
                # Explicit formatting for each column
                formats = [
                    ".0f",     # Symbol 
                    ".0f",     # Rank
                    ".2f",     # Start Price
                    ".2f",     # End Price
                    "+.2f",    # Change%
                    ".4f",     # Coins Qty
                    ".2f",     # Position USD
                    ".2f",     # % of Basket
                    "+.2f",    # P&L (USD)
                    ".2f"      # Target Weight%
                ]
                
                print(tabulate(alt_pnl_data, headers=headers, tablefmt="grid", 
                              floatfmt=formats, numalign="right"))
                
                # Add summary row after table
                print("\n┌─────────────────────────────────────────────────────────────────────────────┐")
                print(f"│ ALT SHORT POSITIONS RESULT:                                                  │")
                print(f"│   Number of ALTs:       {len(alt_coin_quantities):15d}                                         │")
                print(f"│   Total Position Value: ${sum(current_alt_values.values()):15,.2f} USD                                │")
                print(f"│   Weekly P&L:           ${weekly_alt_pnl_usd:+15,.2f} USD                                │")
                print("└─────────────────────────────────────────────────────────────────────────────┘")
            else:
                print("No valid ALT positions to display.")
        
        # ===== 3. UPDATE PORTFOLIO EQUITY AND SHOW WEEKLY SUMMARY =====
        total_weekly_pnl = btc_pnl_usd + weekly_alt_pnl_usd
        weekly_return_pct = (total_weekly_pnl / equity) * 100
        
        # Update cumulative P&L and equity
        cum_btc_pnl += btc_pnl_usd
        cum_alt_pnl += weekly_alt_pnl_usd
        equity += total_weekly_pnl
        
        # Print week summary
        print("\n\n")
        print("┌─────────────────────────────────────────────────────────────────────────────┐")
        print(f"│                       WEEK {i+1} RESULTS - END OF WEEK                       │")
        print("├─────────────────────────────────────────────────────────────────────────────┤")
        print(f"│ PORTFOLIO PERFORMANCE ({pd.Timestamp(t0).strftime('%Y-%m-%d')} - {pd.Timestamp(t1).strftime('%Y-%m-%d')}):                           │")
        print(f"│   BTC Long P&L:        ${btc_pnl_usd:+15,.2f} USD                                │")
        print(f"│   ALT Short P&L:       ${weekly_alt_pnl_usd:+15,.2f} USD                                │")
        print(f"│   ───────────────────────────────────────────────────────────────────────  │")
        print(f"│   TOTAL P&L:           ${total_weekly_pnl:+15,.2f} USD     (return: {weekly_return_pct:+7.2f}%)        │")
        print("├─────────────────────────────────────────────────────────────────────────────┤")
        print(f"│ UPDATED PORTFOLIO STATUS (AFTER P&L):                                        │")
        print(f"│   Cumulative P&L:      ${cum_btc_pnl + cum_alt_pnl:+15,.2f} USD                                │")
        print(f"│   Total equity:        ${equity:15,.2f} USD                                │")
        print(f"│   BTC value:           ${btc_qty * btc_price1:15,.2f} USD     ({btc_qty * btc_price1/equity*100:6.2f}% of equity)    │")
        print(f"│   ALT value:           ${sum(current_alt_values.values()):15,.2f} USD     ({sum(current_alt_values.values())/equity*100:6.2f}% of equity)    │")
        print("└─────────────────────────────────────────────────────────────────────────────┘")
        
        # Stop if equity invalid
        if equity <= 0 or pd.isna(equity):
            print("\nEquity invalid or below zero, stopping backtest.")
            break
            
        # Save performance metrics for this week
        rows.append({
            "Date": pd.Timestamp(t1),
            "Equity_USD": equity,
            "BTC_Price_USD": btc_price1,
            "BtcQty": btc_qty,
            "BtcHold_USD": btc_qty * btc_price1,
            "AltShortTarget_USD": alt_w * equity,
            "AltShortActual_USD": sum(current_alt_values.values()) if current_alt_values else 0,
            "AltShortCount": len(alt_coin_quantities),
            "Weekly_BTC_PNL_USD": btc_pnl_usd,
            "Weekly_ALT_PNL_USD": weekly_alt_pnl_usd,
            "Cum_BTC_PNL_USD": cum_btc_pnl,
            "Cum_ALT_PNL_USD": cum_alt_pnl,
            "Weekly_Return_Pct": weekly_return_pct
        })
            
        # Check if we should proceed with rebalancing
        if i < len(weeks) - 2:  # Don't rebalance after the last week
            # ===== 4. REBALANCE POSITIONS FOR NEXT WEEK =====
            print("\n┌─────────────────────────────────────────────────────────────────────────────┐")
            print(f"│                  REBALANCING FOR WEEK {i+2}                                   │")
            print("└─────────────────────────────────────────────────────────────────────────────┘")
            print("\n")
            
            # 4.1 Rebalance BTC position
            target_btc_value = equity * btc_w
            target_alt_value = equity * alt_w
            
            # Print BTC rebalancing info
            print("┌─────────────────────────────────────────────────────────────────────────────┐")
            print(f"│                         BTC REBALANCING - NEXT WEEK                         │")
            print("├─────────────────────────────────────────────────────────────────────────────┤")
            print(f"│ CURRENT STATE BEFORE REBALANCING:                                           │")
            print(f"│   • Total equity:        ${equity:15,.2f} USD                                │")
            print(f"│   • BTC value:           ${btc_qty * btc_price1:15,.2f} USD = {btc_qty * btc_price1/equity*100:6.2f}% of equity    │")
            print("├─────────────────────────────────────────────────────────────────────────────┤")
            print(f"│ TARGET STATE AFTER REBALANCING:                                             │")
            print(f"│   • Target BTC:          ${target_btc_value:15,.2f} USD = {btc_w*100:6.2f}% of equity    │")
            print("├─────────────────────────────────────────────────────────────────────────────┤")
            
            # Calculate new BTC quantity using CURRENT week's end price (t1)
            current_btc_qty = btc_qty
            new_btc_qty = target_btc_value / btc_price1
            
            # Calculate percentage changes
            qty_change = new_btc_qty - current_btc_qty
            qty_change_pct = (qty_change / current_btc_qty) * 100 if current_btc_qty != 0 else 0
            
            print(f"│ NEW BTC POSITION CALCULATION:                                               │")
            print(f"│   • Formula:             (Target % × Equity) ÷ Current BTC Price            │")
            print(f"│   • Calculation:         ({btc_w:.2f} × ${equity:,.2f}) ÷ ${btc_price1:,.2f} = {new_btc_qty:.6f} BTC  │")
            print("├─────────────────────────────────────────────────────────────────────────────┤")
            print(f"│ REBALANCED BTC POSITION FOR WEEK {i+2}:                                       │")
            print(f"│   • Current quantity:    {current_btc_qty:15.6f} BTC                                  │")
            print(f"│   • New quantity:        {new_btc_qty:15.6f} BTC   (change: {qty_change:+.6f} BTC)    │")
            print(f"│   • Current value:       ${current_btc_qty * btc_price1:15,.2f} USD = {current_btc_qty * btc_price1/equity*100:6.2f}% of equity    │")
            print(f"│   • New value:           ${new_btc_qty * btc_price1:15,.2f} USD = {new_btc_qty * btc_price1/equity*100:6.2f}% of equity    │")
            print(f"│                                                                             │")
            print(f"│   Required position change: {qty_change:+15.6f} BTC    ({qty_change_pct:+7.2f}%)           │")
            print("└─────────────────────────────────────────────────────────────────────────────┘")
            
            # Update BTC position for next week
            btc_qty = new_btc_qty
            
            # 4.2 Rebalance ALT shorts using CURRENT week's data (t1)
            alt_notional_usd_target = alt_w * equity
            
            # Apply filter for excluded symbols
            filtered_w1 = w1[~w1.index.isin(excluded)]
            if "BTC" in filtered_w1.index:
                print(f"WARNING: BTC found in filtered dataframe during rebalancing, removing it")
                filtered_w1 = filtered_w1.drop("BTC", errors="ignore")
                
            # Select top_n by rank
            alts_df_t1 = filtered_w1.nsmallest(top_n, "rank") if not filtered_w1.empty else filtered_w1
            
            # Track which symbols are changing
            old_symbols = set(alt_coin_quantities.keys())
            new_symbols = set(alts_df_t1.index)
            added = new_symbols - old_symbols
            removed = old_symbols - new_symbols
            
            print("\n┌─────────────────────────────────────────────────────────────────────────────┐")
            print(f"│                           ALT BASKET REBALANCING                             │")
            print("├─────────────────────────────────────────────────────────────────────────────┤")
            
            if added or removed:
                if added:
                    added_str = ', '.join(sorted(added))
                    print(f"│ BASKET CHANGES:                                                             │")
                    print(f"│   Added to basket:      {added_str:<50}  │")
                if removed:
                    removed_str = ', '.join(sorted(removed))
                    print(f"│   Removed from basket:  {removed_str:<50}  │")
                print("├─────────────────────────────────────────────────────────────────────────────┤")
            else:
                print(f"│ Basket composition remains unchanged.                                        │")
                print("├─────────────────────────────────────────────────────────────────────────────┤")
                
            # Initialize new ALT tracking dictionaries
            new_alt_coin_quantities = {}
            new_alt_notional_values = {}
            new_alt_weights = {}
            new_alt_values = {}
            
            if not alts_df_t1.empty:
                tot_mcap = alts_df_t1["mcap_btc"].sum()
                
                if tot_mcap > 0 and not pd.isna(tot_mcap):
                    # Calculate new quantities
                    alt_data = {}
                    
                    for sym, r in alts_df_t1.iterrows():
                        if not pd.isna(r.price_usd) and r.price_usd != 0 and not pd.isna(r.mcap_btc):
                            # Calculate weight based on market cap using CURRENT week data
                            weight = r.mcap_btc / tot_mcap
                            new_alt_weights[sym] = weight
                            
                            # Calculate target USD value for this altcoin
                            target_usd_value = alt_notional_usd_target * weight
                            
                            # IMPORTANT: Calculate coin quantity using CURRENT WEEK prices (t1)
                            # This is for next week's positions
                            coin_qty = -target_usd_value / r.price_usd
                            new_alt_coin_quantities[sym] = coin_qty
                            
                            # Store notional USD value (negative for short)
                            new_alt_notional_values[sym] = -target_usd_value
                            
                            # Store position value (absolute)
                            new_alt_values[sym] = abs(new_alt_notional_values[sym])
                            
                            # Store data for display
                            alt_data[sym] = {
                                'rank': r.rank,
                                'qty': coin_qty,  # Actual coin quantity (negative for short)
                                'price_usd': r.price_usd,
                                'price_btc': r.price_btc,
                                'mcap_btc': r.mcap_btc
                            }
                    
                    # Print rebalanced portfolio
                    if alt_data:
                        print_alt_portfolio_table(alt_data, new_alt_weights, new_alt_values, "REBALANCED ALT SHORT BASKET")
                    
                    # Summary of rebalancing
                    old_alt_value = sum(current_alt_values.values())
                    new_alt_value = sum(new_alt_values.values())
                    
                    print("\n┌─────────────────────────────────────────────────────────────────────────────┐")
                    print(f"│                    ALT SHORT REBALANCING - NEXT WEEK                         │")
                    print("├─────────────────────────────────────────────────────────────────────────────┤")
                    print(f"│ ORIGINAL ALT POSITIONS:                                                      │")
                    print(f"│   Number of ALTs:       {len(alt_coin_quantities):15d}                                         │")
                    print(f"│   ALT Position Value:   ${old_alt_value:15,.2f} USD = {old_alt_value/equity*100:6.2f}% of equity    │")
                    print("├─────────────────────────────────────────────────────────────────────────────┤")
                    print(f"│ REBALANCED ALT POSITIONS:                                                    │")
                    print(f"│   Number of ALTs:       {len(new_alt_coin_quantities):15d}                                         │")
                    print(f"│   Target Value:         ${alt_notional_usd_target:15,.2f} USD = {alt_w*100:6.2f}% of equity    │")
                    print(f"│   Actual Value:         ${new_alt_value:15,.2f} USD = {new_alt_value/equity*100:6.2f}% of equity    │")
                    print("└─────────────────────────────────────────────────────────────────────────────┘")
                    
                    # Update ALT positions for next week
                    alt_coin_quantities = new_alt_coin_quantities
                    alt_notional_values = new_alt_notional_values
                    alt_weights = new_alt_weights
                    alt_values = new_alt_values
                else:
                    print("No valid ALTs in rebalanced basket.")
            else:
                print("No altcoins available. Clearing ALT short positions.")
                alt_coin_quantities.clear()
                alt_notional_values.clear()
                alt_weights.clear()
                alt_values.clear()
        else:
            # Last week - end of backtest
            print("\n┌─────────────────────────────────────────────────────────────────────────────┐")
            print(f"│                       END OF BACKTEST - FINAL WEEK                           │")
            print("└─────────────────────────────────────────────────────────────────────────────┘")

    # ===== FINAL SUMMARY =====
    print("\n\n")
    print("┏" + "━" * 80 + "┓")
    print(f"┃{'BACKTEST RESULTS - FINAL SUMMARY':^80}┃")
    print("┗" + "━" * 80 + "┛")
    print("\n")
    
    perf_df = pd.DataFrame(rows)
    
    # Create detailed positions DataFrame
    detailed_df = pd.DataFrame(detailed_positions) if detailed_positions else pd.DataFrame()
    
    # Calculate summary statistics
    final_btc_price = perf_df.iloc[-1]["BTC_Price_USD"] if not perf_df.empty and "BTC_Price_USD" in perf_df.columns else 0
    btc_equiv = equity / final_btc_price if final_btc_price and final_btc_price != 0 else 0
    
    total_return_pct = ((equity - start_cap) / start_cap) * 100
    weekly_returns = perf_df["Weekly_Return_Pct"].dropna().values if not perf_df.empty else []
    annualized_return = total_return_pct * (52 / len(weekly_returns)) if weekly_returns.size > 0 else 0
    max_drawdown = calculate_max_drawdown(perf_df) if not perf_df.empty else 0
    
    # Assemble summary dictionary
    summary = {
        "cum_btc_pnl": cum_btc_pnl,
        "cum_alt_pnl": cum_alt_pnl,
        "final_equity": equity,
        "btc_equiv": btc_equiv,
        "total_return_pct": total_return_pct,
        "annualized_return": annualized_return,
        "max_drawdown": max_drawdown,
        "sharpe_ratio": calculate_sharpe_ratio(weekly_returns) if weekly_returns.size > 0 else 0,
        "sortino_ratio": calculate_sortino_ratio(weekly_returns) if weekly_returns.size > 0 else 0,
        "win_rate": np.mean(weekly_returns > 0) * 100 if weekly_returns.size > 0 else 0,
    }
    
    return perf_df, summary, detailed_df


def calculate_max_drawdown(perf_df: pd.DataFrame) -> float:
    """Calculate maximum drawdown from equity curve."""
    if "Equity_USD" not in perf_df.columns or perf_df.empty:
        return 0.0
    
    equity = perf_df["Equity_USD"].values
    peak = np.maximum.accumulate(equity)
    drawdown = (equity - peak) / peak
    return abs(min(drawdown)) * 100  # Convert to percentage


def calculate_sharpe_ratio(returns: np.ndarray, risk_free_rate: float = 0.02) -> float:
    """Calculate annualized Sharpe ratio from weekly returns."""
    if returns.size == 0:
        return 0.0
    
    # Convert weekly returns to annualized values
    annualized_return = np.mean(returns) * 52
    annualized_volatility = np.std(returns) * np.sqrt(52)
    
    if annualized_volatility == 0:
        return 0.0
        
    return (annualized_return - risk_free_rate) / annualized_volatility


def calculate_sortino_ratio(returns: np.ndarray, risk_free_rate: float = 0.02) -> float:
    """Calculate annualized Sortino ratio from weekly returns."""
    if returns.size == 0:
        return 0.0
    
    # Calculate downside deviation (only negative returns)
    negative_returns = returns[returns < 0]
    
    if negative_returns.size == 0:
        return np.inf  # No negative returns means infinite Sortino ratio
    
    downside_deviation = np.std(negative_returns) * np.sqrt(52)
    
    if downside_deviation == 0:
        return 0.0
        
    annualized_return = np.mean(returns) * 52
    return (annualized_return - risk_free_rate) / downside_deviation


def plot_equity_curve(perf_df: pd.DataFrame, summary: dict, start_date: dt.datetime, end_date: dt.datetime) -> plt.Figure:
    """Plot equity curve with drawdowns and key metrics."""
    if not perf_df.empty and "Equity_USD" in perf_df.columns:
        plot_data = perf_df.dropna(subset=["Equity_USD", "Date"])
        if not plot_data.empty:
            # Create subplots: equity curve and weekly returns
            fig, (ax1, ax2) = plt.subplots(2, 1, figsize=(12, 10), 
                                         gridspec_kw={'height_ratios': [3, 1]})
            
            # --- Equity Curve (Top Plot) ---
            ymin = min(START_CAP, plot_data["Equity_USD"].min()) * 0.9
            ymax = max(START_CAP, plot_data["Equity_USD"].max()) * 1.1
            ymin = max(0, ymin)
            if ymin >= ymax:
                ymax = ymin * 1.2 if ymin > 0 else START_CAP * 1.1
                
            fmt = ScalarFormatter(useOffset=False)
            fmt.set_scientific(False)
            
            # Plot equity curve
            ax1.plot(plot_data["Date"], plot_data["Equity_USD"], marker=".", linestyle="-", 
                    color='blue', linewidth=2, label="Portfolio Value")
            
            # Get strategy parameters from the display name in summary
            strategy_title = f"Equity Curve: {start_date.date()} to {end_date.date()}"
            
            # Check if we have BtcQty and AltShortTarget_USD in the dataframe to calculate weights
            if "BtcQty" in plot_data.columns and "AltShortTarget_USD" in plot_data.columns and "Equity_USD" in plot_data.columns:
                # Take values from the first row to get the strategy parameters
                first_row = plot_data.iloc[0]
                if "BTC_Price_USD" in first_row and first_row["BTC_Price_USD"] > 0:
                    btc_value = first_row["BtcQty"] * first_row["BTC_Price_USD"]
                    btc_weight = btc_value / first_row["Equity_USD"] if first_row["Equity_USD"] > 0 else 0
                    alt_weight = first_row["AltShortTarget_USD"] / first_row["Equity_USD"] if first_row["Equity_USD"] > 0 else 0
                    top_n = int(first_row["AltShortCount"]) if "AltShortCount" in first_row else 0
                    total_leverage = btc_weight + alt_weight
                    
                    strategy_title = f"{btc_weight*100:.1f}% BTC long + {alt_weight*100:.1f}% ALT short (Top {top_n}, {total_leverage:.1f}x leverage)"
            
            date_range = f"[{start_date.date()} to {end_date.date()}]"
            ax1.set_title(f"{strategy_title}\n{date_range}", fontsize=14)
            
            ax1.set_xlabel("")  # We'll put the label on the bottom plot
            ax1.set_ylabel("Equity (USD)", fontsize=12)
            ax1.set_ylim(ymin, ymax)
            ax1.grid(True, which="major", linestyle="--", alpha=0.7)
            ax1.grid(True, which="minor", linestyle=":", alpha=0.5)
            ax1.minorticks_on()
            ax1.yaxis.set_major_formatter(fmt)
            ax1.axhline(START_CAP, color="red", linestyle="--", linewidth=1, 
                       label=f"Initial Capital (${START_CAP:,.0f})")
            
            # Calculate drawdown for shading
            equity = plot_data["Equity_USD"].values
            dates = plot_data["Date"].values
            peak = np.maximum.accumulate(equity)
            drawdown = (equity - peak) / peak
            
            # Color the background based on drawdown severity
            for i in range(1, len(drawdown)):
                if drawdown[i] < -0.05:  # More than 5% drawdown
                    color = 'salmon'
                    alpha = min(0.3, abs(drawdown[i]))
                    ax1.axvspan(dates[i-1], dates[i], color=color, alpha=alpha)
            
            # Add key metrics as text box
            metrics_text = (
                f"Total Return: {summary['total_return_pct']:.2f}%\n"
                f"Annualized: {summary['annualized_return']:.2f}%\n"
                f"Max Drawdown: {summary['max_drawdown']:.2f}%\n"
                f"Sharpe Ratio: {summary['sharpe_ratio']:.2f}\n"
                f"Win Rate: {summary['win_rate']:.1f}%"
            )
            ax1.text(0.02, 0.02, metrics_text, transform=ax1.transAxes, fontsize=10,
                   bbox=dict(boxstyle="round,pad=0.3", fc="wheat", alpha=0.7))
            
            ax1.legend(loc='upper left')
            
            # --- Weekly Returns (Bottom Plot) ---
            if "Weekly_Return_Pct" in plot_data.columns:
                returns = plot_data["Weekly_Return_Pct"]
                
                # Create bar plot of weekly returns
                colors = ['green' if r >= 0 else 'red' for r in returns]
                ax2.bar(plot_data["Date"], returns, color=colors, alpha=0.7, width=6)
                
                ax2.axhline(0, color='black', linestyle='-', linewidth=0.5)
                ax2.set_xlabel("Date", fontsize=12)
                ax2.set_ylabel("Weekly Return (%)", fontsize=12)
                ax2.yaxis.set_major_formatter(PercentFormatter())
                ax2.grid(True, axis='y', linestyle='--', alpha=0.5)
                
                # Set date formatting to match the top plot
                fig.autofmt_xdate()
            
            plt.tight_layout()
            return fig
        
    # Return None if we couldn't create a plot
    return None


def plot_btc_vs_alts(perf_df: pd.DataFrame) -> plt.Figure:
    """Plot separate performance of BTC long vs ALT short legs."""
    if not perf_df.empty and all(col in perf_df.columns for col in ["Cum_BTC_PNL_USD", "Cum_ALT_PNL_USD", "Date"]):
        # Create figure
        fig, ax = plt.subplots(figsize=(12, 6))
        
        # Plot cumulative P/L for each leg
        ax.plot(perf_df["Date"], perf_df["Cum_BTC_PNL_USD"], 
                marker="", linestyle="-", color='blue', linewidth=2, 
                label="BTC Long Cumulative P/L")
        
        ax.plot(perf_df["Date"], perf_df["Cum_ALT_PNL_USD"], 
                marker="", linestyle="-", color='red', linewidth=2, 
                label="ALT Short Cumulative P/L")
        
        # Plot total P/L
        total_pnl = perf_df["Cum_BTC_PNL_USD"] + perf_df["Cum_ALT_PNL_USD"]
        ax.plot(perf_df["Date"], total_pnl, 
                marker="", linestyle="-", color='green', linewidth=2, 
                label="Total Cumulative P/L")
        
        # Create a strategy description from the data
        strategy_title = "BTC Long vs ALT Short - Cumulative P/L Contribution"
        
        # Check if we have weights in the data
        if "BtcQty" in perf_df.columns and "AltShortTarget_USD" in perf_df.columns and "Equity_USD" in perf_df.columns:
            # Take values from the first row to get the strategy parameters
            first_row = perf_df.iloc[0]
            if "BTC_Price_USD" in first_row and first_row["BTC_Price_USD"] > 0:
                btc_value = first_row["BtcQty"] * first_row["BTC_Price_USD"]
                btc_weight = btc_value / first_row["Equity_USD"] if first_row["Equity_USD"] > 0 else 0
                alt_weight = first_row["AltShortTarget_USD"] / first_row["Equity_USD"] if first_row["Equity_USD"] > 0 else 0
                total_leverage = btc_weight + alt_weight
                
                strategy_title = f"BTC Long ({btc_weight*100:.1f}%) vs ALT Short ({alt_weight*100:.1f}%) - P/L Contribution ({total_leverage:.1f}x leverage)"
        
        # Style the plot
        ax.set_title(strategy_title, fontsize=14)
        ax.set_xlabel("Date", fontsize=12)
        ax.set_ylabel("Cumulative P/L (USD)", fontsize=12)
        
        # Add zero line
        ax.axhline(0, color='black', linestyle='-', linewidth=0.5)
        
        # Add grid and legend
        ax.grid(True, linestyle='--', alpha=0.7)
        ax.legend(loc='best')
        
        # Format dates on x-axis
        fig.autofmt_xdate()
        plt.tight_layout()
        
        return fig
    
    return None


def export_detailed_report(perf_df: pd.DataFrame, summary: dict, detailed_df: pd.DataFrame, 
                         start_date: dt.datetime, end_date: dt.datetime):
    """Export detailed backtest report to CSV files and plots."""
    # Create reports directory if it doesn't exist
    REPORTS_DIR.mkdir(exist_ok=True)
    
    # Delete existing files if overwrite is needed
    if OVERWRITE_REPORTS:
        for pattern in ["performance_*.csv", "positions_*.csv", "summary_*.txt", 
                      "equity_curve_*.png", "contribution_*.png"]:
            for old_file in REPORTS_DIR.glob(pattern):
                old_file.unlink(missing_ok=True)
    
    # Generate timestamp for filenames
    timestamp = dt.datetime.now().strftime("%Y%m%d_%H%M%S")
    
    # Export performance dataframe
    if not perf_df.empty:
        perf_file = REPORTS_DIR / f"performance_{timestamp}.csv"
        perf_df.to_csv(perf_file, index=False)
        print(f"Exported performance data to {perf_file}")
    
    # Export detailed positions dataframe
    if not detailed_df.empty:
        detail_file = REPORTS_DIR / f"positions_{timestamp}.csv"
        detailed_df.to_csv(detail_file, index=False)
        print(f"Exported detailed position data to {detail_file}")
    
    # Export summary as text file
    summary_file = REPORTS_DIR / f"summary_{timestamp}.txt"
    with open(summary_file, "w") as f:
        f.write(f"Backtest Summary: {start_date.date()} to {end_date.date()}\n")
        
        # Extract strategy parameters from performance data if available
        btc_weight = ALT_weight = top_n_alts = None
        total_leverage = 0
        
        if not perf_df.empty and "BtcQty" in perf_df.columns and "AltShortTarget_USD" in perf_df.columns:
            first_row = perf_df.iloc[0]
            if "BTC_Price_USD" in first_row and first_row["BTC_Price_USD"] > 0:
                btc_value = first_row["BtcQty"] * first_row["BTC_Price_USD"]
                btc_weight = btc_value / first_row["Equity_USD"] if first_row["Equity_USD"] > 0 else 0
                ALT_weight = first_row["AltShortTarget_USD"] / first_row["Equity_USD"] if first_row["Equity_USD"] > 0 else 0
                top_n_alts = int(first_row["AltShortCount"]) if "AltShortCount" in first_row else 0
                total_leverage = btc_weight + ALT_weight
        
        # Fallback to global constants if we couldn't extract from data
        if btc_weight is None:
            btc_weight = BTC_W
            ALT_weight = ALT_W
            top_n_alts = TOP_N
            total_leverage = btc_weight + ALT_weight
        
        f.write(f"Strategy: {btc_weight*100:.1f}% BTC long + {ALT_weight*100:.1f}% ALT short (Top {top_n_alts})\n")
        f.write(f"Total Leverage: {total_leverage:.2f}x\n\n")
        
        f.write("Contribution Analysis:\n")
        f.write(f"BTC Long P/L:      ${summary['cum_btc_pnl']:+,.2f}\n")
        f.write(f"ALT Short P/L:     ${summary['cum_alt_pnl']:+,.2f}\n")
        f.write(f"Total P/L:         ${summary['cum_btc_pnl'] + summary['cum_alt_pnl']:+,.2f}\n\n")
        
        f.write("Performance Metrics:\n")
        f.write(f"Initial Capital:   ${START_CAP:,.2f}\n")
        f.write(f"Final Equity:      ${summary['final_equity']:,.2f}\n")
        f.write(f"Total Return:      {summary['total_return_pct']:+.2f}%\n")
        f.write(f"Annualized Return: {summary['annualized_return']:+.2f}%\n")
        f.write(f"Maximum Drawdown:  {summary['max_drawdown']:.2f}%\n")
        f.write(f"Sharpe Ratio:      {summary['sharpe_ratio']:.2f}\n")
        f.write(f"Sortino Ratio:     {summary['sortino_ratio']:.2f}\n")
        f.write(f"Win Rate:          {summary['win_rate']:.1f}%\n")
    
    print(f"Exported summary to {summary_file}")
    
    # Save plots
    equity_fig = plot_equity_curve(perf_df, summary, start_date, end_date)
    if equity_fig:
        equity_plot_file = REPORTS_DIR / f"equity_curve_{timestamp}.png"
        equity_fig.savefig(equity_plot_file, dpi=300, bbox_inches="tight")
        print(f"Exported equity curve plot to {equity_plot_file}")
    
    contribution_fig = plot_btc_vs_alts(perf_df)
    if contribution_fig:
        contrib_plot_file = REPORTS_DIR / f"contribution_{timestamp}.png"
        contribution_fig.savefig(contrib_plot_file, dpi=300, bbox_inches="tight")
        print(f"Exported contribution plot to {contrib_plot_file}")


def main():
    if not CSV_PATH.exists():
        print(f"CSV not found: {CSV_PATH}")
        return
        
    print(f"Loading data from {CSV_PATH}")
    print(f"Date range: {START_DATE.date()} to {END_DATE.date()}")
    
    df = load_and_prepare(CSV_PATH, START_DATE, END_DATE)
    print(f"Loaded {len(df)} rows over {df['rebalance_ts'].nunique()} weeks")
    
    # Run backtest
    perf, summary, detailed = backtest_rank_altbtc_short(df)
    
    # Display summary
    if summary:
        print("\n========== FINAL SUMMARY ==========")
        
        # Contribution analysis
        print("\n┌─────────────────────────────────────────────────────┐")
        print("│                CONTRIBUTION ANALYSIS                 │")
        print("├─────────────────────────────────────────────────────┤")
        print(f"│ BTC Long P&L:      ${summary['cum_btc_pnl']:+15,.2f} USD        │")
        print(f"│ ALT Short P&L:     ${summary['cum_alt_pnl']:+15,.2f} USD        │")
        print(f"├─────────────────────────────────────────────────────┤")
        print(f"│ Total P&L:         ${summary['cum_btc_pnl'] + summary['cum_alt_pnl']:+15,.2f} USD        │")
        print("└─────────────────────────────────────────────────────┘")
        
        print("\n┌─────────────────────────────────────────────────────┐")
        print("│                 PERFORMANCE METRICS                  │")
        print("├─────────────────────────────────────────────────────┤")
        print(f"│ Initial capital:   ${START_CAP:15,.2f} USD        │")
        print(f"│ Final equity:      ${summary['final_equity']:15,.2f} USD        │")
        print(f"├─────────────────────────────────────────────────────┤")
        print(f"│ Total return:      {summary['total_return_pct']:+15.2f}%          │")
        print(f"│ Annualized return: {summary['annualized_return']:+15.2f}%          │")
        print(f"│ Maximum drawdown:  {summary['max_drawdown']:15.2f}%          │")
        print(f"├─────────────────────────────────────────────────────┤")
        print(f"│ Sharpe ratio:      {summary['sharpe_ratio']:15.2f}           │")
        print(f"│ Sortino ratio:     {summary['sortino_ratio']:15.2f}           │")
        print(f"│ Win rate:          {summary['win_rate']:15.1f}%          │")
        print("└─────────────────────────────────────────────────────┘")
        
        # Export detailed report
        export_detailed_report(perf, summary, detailed, START_DATE, END_DATE)
        
        # Show plots
        equity_fig = plot_equity_curve(perf, summary, START_DATE, END_DATE)
        if equity_fig:
            plt.figure(equity_fig.number)
            plt.show()
        
        contribution_fig = plot_btc_vs_alts(perf)
        if contribution_fig:
            plt.figure(contribution_fig.number)
            plt.show()
    else:
        print("Backtest did not produce a summary.")


if __name__ == "__main__":
    main()