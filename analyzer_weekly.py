#!/usr/bin/env python3
"""
Analyzer for BTC long vs ALT short backtest using weekly top-100 snapshots.
Data source: top100_weekly_2021-2025.csv (generated by fetcher.py).
"""
from pathlib import Path
import pandas as pd
import matplotlib.pyplot as plt
from matplotlib.ticker import ScalarFormatter
import datetime as dt

# Import configuration
from config.config import (
    EXCLUDED_SYMBOLS,
    BACKTEST_START_DATE,
    BACKTEST_END_DATE,
    BACKTEST_INITIAL_CAPITAL,
    BACKTEST_BTC_WEIGHT,
    BACKTEST_ALT_WEIGHT,
    BACKTEST_TOP_N_ALTS
)

# Configuration with defaults from config.py
CSV_PATH = Path("top100_weekly_2021-2025.csv")
START_CAP = BACKTEST_INITIAL_CAPITAL
BTC_W = BACKTEST_BTC_WEIGHT
ALT_W = BACKTEST_ALT_WEIGHT
TOP_N = BACKTEST_TOP_N_ALTS
EXCLUDED = EXCLUDED_SYMBOLS
# Date range for backtesting
START_DATE = BACKTEST_START_DATE
END_DATE = BACKTEST_END_DATE


def load_and_prepare(csv_path: Path, start_date=None, end_date=None) -> pd.DataFrame:
    """
    Load CSV from csv_path, clean numeric columns, compute price_btc and mcap_btc columns.
    Optionally filters data by date range.
    
    Args:
        csv_path: Path to the CSV file
        start_date: Optional start date to filter data (inclusive)
        end_date: Optional end date to filter data (inclusive)
        
    Returns:
        DataFrame compatible with backtest_rank_altbtc_short.
    """
    df = pd.read_csv(csv_path)
    # parse date
    df["snapshot_date"] = pd.to_datetime(df["snapshot_date"])
    
    # Filter by date range if provided
    if start_date:
        df = df[df["snapshot_date"] >= pd.Timestamp(start_date)]
    if end_date:
        df = df[df["snapshot_date"] <= pd.Timestamp(end_date)]
        
    # rename to match old analyzer expectations
    df = df.rename(
        columns={
            "snapshot_date": "rebalance_ts",
            "symbol": "sym",
            "price": "price_usd",
            "market_cap": "market_cap_usd",
        }
    )
    # clean numeric columns
    for col in ["price_usd", "market_cap_usd", "volume_24h"]:
        if col in df.columns:
            df[col] = (
                df[col]
                .astype(str)
                .replace(r"[\$,]", "", regex=True)
                .astype(float)
            )
    # map BTC price per week
    btc_prices = (
        df.loc[df["sym"] == "BTC", ["rebalance_ts", "price_usd"]]
        .drop_duplicates()
        .set_index("rebalance_ts")["price_usd"]
    )
    # assign btc_price_usd
    df["btc_price_usd"] = df["rebalance_ts"].map(btc_prices)
    # compute price_btc and mcap_btc
    df["price_btc"] = df["price_usd"] / df["btc_price_usd"]
    df["mcap_btc"] = df["market_cap_usd"] / df["btc_price_usd"]
    # ensure rank integer
    df["rank"] = df["rank"].astype(int)
    # drop rows lacking key data
    df = df.dropna(subset=["rebalance_ts", "sym", "btc_price_usd", "price_usd", "price_btc", "mcap_btc", "rank"])
    return df
    
def backtest_rank_altbtc_short(df: pd.DataFrame,
                               btc_w: float = BTC_W,
                               alt_w: float = ALT_W,
                               top_n: int = TOP_N,
                               excluded: list = None,
                               start_cap: float = START_CAP) -> tuple[pd.DataFrame, dict]:
    """
    Backtest the BTC long vs ALT short strategy.
    
    Args:
        df: DataFrame with prepared cryptocurrency data
        btc_w: Weight of BTC position (0-1)
        alt_w: Weight of ALT position (0-1)
        top_n: Number of top altcoins to include in the short basket
        excluded: List of symbols to exclude from the short basket
        start_cap: Initial capital in USD
        
    Returns:
        Tuple of (performance DataFrame, summary dictionary)
    """
    if excluded is None:
        excluded = EXCLUDED
        
    weeks = sorted(df["rebalance_ts"].unique())
    equity = start_cap

    btc_qty = 0.0
    alt_qty: dict[str, float] = {}

    rows = []
    cum_btc_pnl = cum_alt_pnl = 0.0
    total_alt_pnl_btc = 0.0

    print("--- Backtest Start ---")
    print(f"Strategy: {btc_w * 100}% Long BTC/USD, {alt_w * 100}% Short ALT/BTC (Top {top_n})")
    print(f"Date Range: {pd.Timestamp(weeks[0]).date()} to {pd.Timestamp(weeks[-1]).date()}")
    print(f"Excluded from Alts: {excluded}")
    print(f"Initial Equity: {start_cap:,.2f} USD")
    print("-" * 50)

    for i in range(len(weeks) - 1):
        t0, t1 = weeks[i], weeks[i + 1]
        w0 = df[df.rebalance_ts == t0].set_index('sym')
        w1 = df[df.rebalance_ts == t1].set_index('sym')

        # BTC prices
        try:
            btc_price0 = w0["btc_price_usd"].mean()
            btc_price1 = w1["btc_price_usd"].mean()
            if pd.isna(btc_price0) or pd.isna(btc_price1) or btc_price0 == 0:
                raise ValueError("BTC price is NaN or zero")
        except Exception as e:
            print(f"Error getting BTC price: {e}")
            if i == 0:
                print("Cannot initialize positions without BTC price.")
                return pd.DataFrame(), {}
            else:
                print("Holding previous positions due to missing BTC price.")
                if rows:
                    last_row = rows[-1]
                    rows.append({**last_row, 'Date': pd.Timestamp(t1), 'BTC_Price_USD': None})
                continue

        if i == 0:
            # initialize
            print(f"{pd.Timestamp(t0).date()} | Initializing positions...")
            btc_qty = (btc_w * equity) / btc_price0
            print(f"  BTC Long: Qty={btc_qty:.6f} BTC @ ${btc_price0:,.2f}/BTC | Value=${btc_qty * btc_price0:,.2f}")

            alt_notional_usd_target = alt_w * equity
            alts_df_t0 = w0[~w0.index.isin(excluded)].nsmallest(top_n, "rank")
            actual_alt_usd_value_total = 0.0
            temp_alt_qty: dict[str, float] = {}
            if not alts_df_t0.empty:
                tot_mcap = alts_df_t0["mcap_btc"].sum()
                if tot_mcap > 0 and not pd.isna(tot_mcap):
                    print(f"  Target ALT Short Leg Value: ${alt_notional_usd_target:,.2f}")
                    for sym, r in alts_df_t0.iterrows():
                        if not pd.isna(r.price_btc) and r.price_btc != 0 and not pd.isna(r.mcap_btc):
                            alt_usd_target_sym = alt_notional_usd_target * (r.mcap_btc / tot_mcap)
                            qty = -(alt_usd_target_sym / (r.price_btc * btc_price0))
                            temp_alt_qty[sym] = qty
                            actual_usd_value_sym = abs(qty * r.price_btc * btc_price0)
                            actual_alt_usd_value_total += actual_usd_value_sym
                            print(
                                f"    {sym}: Weight={r.mcap_btc / tot_mcap:.2%}, "
                                f"Target=${alt_usd_target_sym:,.2f}, Qty={qty:,.4f}, "
                                f"ActualValue=${actual_usd_value_sym:,.2f}")
                        else:
                            print(f"  Skipping {sym} due to invalid price/mcap.")
                    alt_qty = temp_alt_qty
                    print(f"  Total ALT Short Initialized: ${actual_alt_usd_value_total:,.2f}")
                else:
                    print("Warning: Total mcap_btc zero or NaN at init. No ALT shorts.")
                    alt_qty = {}
            rows.append({
                "Date": pd.Timestamp(t0),
                "Equity_USD": equity,
                "BTC_Price_USD": btc_price0,
                "BtcQty": btc_qty,
                "BtcHold_USD": btc_qty * btc_price0,
                "AltShortTarget_USD": alt_notional_usd_target,
                "AltShortActual_USD": actual_alt_usd_value_total,
                "AltShortCount": len(alt_qty),
                "Cum_BTC_PNL_USD": 0.0,
                "Cum_ALT_PNL_USD": 0.0,
                "Cum_ALT_PNL_BTC": 0.0,
            })
            print("-" * 50)
            continue

        # calculate P/L
        print(f"--- Week {pd.Timestamp(t0).date()} -> {pd.Timestamp(t1).date()} ---")
        btc_pnl_usd = (btc_price1 - btc_price0) * btc_qty
        print(f"  BTC PNL: {btc_pnl_usd:+,.2f} USD")

        weekly_alt_pnl_btc = 0.0
        for sym, qty_held in alt_qty.items():
            if sym in w0.index and sym in w1.index:
                p0 = w0.at[sym, "price_btc"]
                p1 = w1.at[sym, "price_btc"]
                if not pd.isna(p0) and not pd.isna(p1):
                    pnl_btc = (p1 - p0) * qty_held
                    weekly_alt_pnl_btc += pnl_btc
                    print(f"    {sym}: PNL_BTC={pnl_btc:+.6f}")
        weekly_alt_pnl_usd = weekly_alt_pnl_btc * btc_price1

        cum_btc_pnl += btc_pnl_usd
        cum_alt_pnl += weekly_alt_pnl_usd
        total_alt_pnl_btc += weekly_alt_pnl_btc
        equity += btc_pnl_usd + weekly_alt_pnl_usd

        if equity <= 0 or pd.isna(equity):
            print("Equity invalid, stopping.")
            break

        # rebalance
        btc_qty = (btc_w * equity) / btc_price1
        alt_notional_usd_target = alt_w * equity
        alts_df_t1 = w1[~w1.index.isin(excluded)].nsmallest(top_n, "rank")
        new_alt_qty: dict[str, float] = {}
        actual_alt_usd_value_total = 0.0
        if not alts_df_t1.empty:
            tot_mcap = alts_df_t1["mcap_btc"].sum()
            if tot_mcap > 0 and not pd.isna(tot_mcap):
                for sym, r in alts_df_t1.iterrows():
                    if not pd.isna(r.price_btc) and r.price_btc != 0 and not pd.isna(r.mcap_btc):
                        alt_usd_target_sym = alt_notional_usd_target * (r.mcap_btc / tot_mcap)
                        qty = -(alt_usd_target_sym / (r.price_btc * btc_price1))
                        new_alt_qty[sym] = qty
                        actual_alt_usd_value_total += abs(qty * r.price_btc * btc_price1)
            alt_qty = new_alt_qty

        rows.append({
            "Date": pd.Timestamp(t1),
            "Equity_USD": equity,
            "BTC_Price_USD": btc_price1,
            "BtcQty": btc_qty,
            "BtcHold_USD": btc_qty * btc_price1,
            "AltShortTarget_USD": alt_notional_usd_target,
            "AltShortActual_USD": actual_alt_usd_value_total,
            "AltShortCount": len(alt_qty),
            "Cum_BTC_PNL_USD": cum_btc_pnl,
            "Cum_ALT_PNL_USD": cum_alt_pnl,
            "Cum_ALT_PNL_BTC": total_alt_pnl_btc,
        })
        print("-" * 50)

    print("\n--- Backtest End ---")
    perf_df = pd.DataFrame(rows)
    btc_equiv = equity / perf_df.iloc[-1]["BTC_Price_USD"] if not perf_df.empty else 0
    summary = {
        "cum_btc_pnl": cum_btc_pnl,
        "cum_alt_pnl": cum_alt_pnl,
        "cum_alt_pnl_btc": total_alt_pnl_btc,
        "final_equity": equity,
        "btc_equiv": btc_equiv,
    }
    return perf_df, summary

def main():
    if not CSV_PATH.exists():
        print(f"CSV not found: {CSV_PATH}")
        return
        
    print(f"Loading data from {CSV_PATH}")
    print(f"Date range: {START_DATE.date()} to {END_DATE.date()}")
    
    df = load_and_prepare(CSV_PATH, START_DATE, END_DATE)
    print(f"Loaded {len(df)} rows over {df['rebalance_ts'].nunique()} weeks")
    
    perf, summary = backtest_rank_altbtc_short(df)
    
    if summary:
        print("\n--- Summary ---")
        print(f"Cumulative BTC P/L : {summary['cum_btc_pnl']:+,.2f} USD")
        print(f"Cumulative ALT P/L : {summary['cum_alt_pnl']:+,.2f} USD ({summary['cum_alt_pnl_btc']:+.6f} BTC)")
        print(f"Final equity       : {summary['final_equity']:,.2f} USD")
        print(f"Final equiv        : {summary['btc_equiv']:.6f} BTC")
        
    # plot
    if not perf.empty and "Equity_USD" in perf.columns:
        plot_data = perf.dropna(subset=["Equity_USD", "Date"])
        if not plot_data.empty:
            ymin = min(START_CAP, plot_data["Equity_USD"].min()) * 0.9
            ymax = max(START_CAP, plot_data["Equity_USD"].max()) * 1.1
            ymin = max(0, ymin)
            if ymin >= ymax:
                ymax = ymin * 1.2 if ymin > 0 else START_CAP * 1.1
                
            fmt = ScalarFormatter(useOffset=False)
            fmt.set_scientific(False)
            fig, ax = plt.subplots(figsize=(12, 6))
            ax.plot(plot_data["Date"], plot_data["Equity_USD"], marker=".", linestyle="-")
            
            title = f"{BTC_W*100:.0f}% BTC long vs {ALT_W*100:.0f}% ALT short (Top {TOP_N})"
            date_range = f"[{START_DATE.date()} to {END_DATE.date()}]"
            ax.set_title(f"{title}\n{date_range}")
            
            ax.set_xlabel("Date")
            ax.set_ylabel("Equity (USD)")
            ax.set_ylim(ymin, ymax)
            ax.grid(True, which="major", linestyle="--", alpha=0.7)
            ax.grid(True, which="minor", linestyle=":", alpha=0.5)
            ax.minorticks_on()
            ax.yaxis.set_major_formatter(fmt)
            ax.axhline(START_CAP, color="red", linestyle="--", linewidth=1)
            
            final_pnl = summary["final_equity"] - START_CAP
            perc = (final_pnl / START_CAP) * 100 if START_CAP else 0
            plt.text(0.02, 0.02, f"Total PNL: ${final_pnl:.2f} ({perc:.2f}%)",
                     transform=ax.transAxes, fontsize=9,
                     bbox=dict(boxstyle="round,pad=0.3", fc="wheat", alpha=0.5))
            fig.autofmt_xdate()
            plt.tight_layout()
            plt.show()
        else:
            print("No plot data.")

if __name__ == "__main__":
    main()