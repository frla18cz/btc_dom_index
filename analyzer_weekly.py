#!/usr/bin/env python3
"""
Analyzer for BTC long vs ALT short backtest using weekly top-100 snapshots.
Data source: top100_weekly_2021-2025.csv (generated by fetcher.py).
"""
from pathlib import Path
import pandas as pd
import matplotlib.pyplot as plt
from matplotlib.ticker import ScalarFormatter, PercentFormatter
import datetime as dt
import numpy as np
from tabulate import tabulate
import textwrap

# Import configuration
from config.config import (
    EXCLUDED_SYMBOLS,
    BACKTEST_START_DATE,
    BACKTEST_END_DATE,
    BACKTEST_INITIAL_CAPITAL,
    BACKTEST_BTC_WEIGHT,
    BACKTEST_ALT_WEIGHT,
    BACKTEST_TOP_N_ALTS
)

# Configuration with defaults from config.py
CSV_PATH = Path("top100_weekly_2021-2025.csv")
START_CAP = BACKTEST_INITIAL_CAPITAL
BTC_W = BACKTEST_BTC_WEIGHT
ALT_W = BACKTEST_ALT_WEIGHT
TOP_N = BACKTEST_TOP_N_ALTS
EXCLUDED = EXCLUDED_SYMBOLS
# Date range for backtesting
START_DATE = BACKTEST_START_DATE
END_DATE = BACKTEST_END_DATE
# Output directory for detailed reports
REPORTS_DIR = Path("reports")


def load_and_prepare(csv_path: Path, start_date=None, end_date=None) -> pd.DataFrame:
    """
    Load CSV from csv_path, clean numeric columns, compute price_btc and mcap_btc columns.
    Optionally filters data by date range.
    
    Args:
        csv_path: Path to the CSV file
        start_date: Optional start date to filter data (inclusive)
        end_date: Optional end date to filter data (inclusive)
        
    Returns:
        DataFrame compatible with backtest_rank_altbtc_short.
    """
    df = pd.read_csv(csv_path)
    # parse date
    df["snapshot_date"] = pd.to_datetime(df["snapshot_date"])
    
    # Filter by date range if provided
    if start_date:
        df = df[df["snapshot_date"] >= pd.Timestamp(start_date)]
    if end_date:
        df = df[df["snapshot_date"] <= pd.Timestamp(end_date)]
        
    # rename to match old analyzer expectations
    df = df.rename(
        columns={
            "snapshot_date": "rebalance_ts",
            "symbol": "sym",
            "price": "price_usd",
            "market_cap": "market_cap_usd",
        }
    )
    # clean numeric columns
    for col in ["price_usd", "market_cap_usd", "volume_24h"]:
        if col in df.columns:
            df[col] = (
                df[col]
                .astype(str)
                .replace(r"[\$,]", "", regex=True)
                .astype(float)
            )
    # map BTC price per week
    btc_prices = (
        df.loc[df["sym"] == "BTC", ["rebalance_ts", "price_usd"]]
        .drop_duplicates()
        .set_index("rebalance_ts")["price_usd"]
    )
    # assign btc_price_usd
    df["btc_price_usd"] = df["rebalance_ts"].map(btc_prices)
    # compute price_btc and mcap_btc
    df["price_btc"] = df["price_usd"] / df["btc_price_usd"]
    df["mcap_btc"] = df["market_cap_usd"] / df["btc_price_usd"]
    # ensure rank integer
    df["rank"] = df["rank"].astype(int)
    # drop rows lacking key data
    df = df.dropna(subset=["rebalance_ts", "sym", "btc_price_usd", "price_usd", "price_btc", "mcap_btc", "rank"])
    return df


def print_header(title, width=80):
    """Print a formatted header with a title."""
    print("\n" + "=" * width)
    print(f"{title:^{width}}")
    print("=" * width)


def print_section(title, width=80):
    """Print a formatted section header."""
    print("\n" + "-" * width)
    print(f"{title:^{width}}")
    print("-" * width)


def format_portfolio_table(data, headers):
    """Format portfolio data as a pretty table."""
    return tabulate(data, headers=headers, tablefmt="grid", floatfmt=".6f")


def print_alt_portfolio_table(alt_data, weights, values, title):
    """Format and print alt portfolio table with weights."""
    print_section(title)
    
    if not alt_data:
        print("No altcoins in portfolio")
        return
    
    # Prepare the table data
    table_data = []
    total_weight = sum(weights.values()) if weights else 0
    total_value = sum(values.values()) if values else 0
    
    for sym, data in alt_data.items():
        weight = weights.get(sym, 0)
        weight_pct = (weight / total_weight * 100) if total_weight > 0 else 0
        value = values.get(sym, 0)
        value_pct = (value / total_value * 100) if total_value > 0 else 0
        
        row = [
            sym,  # Symbol
            data.get('rank', 'N/A'),  # Rank
            data.get('qty', 0),  # Quantity
            data.get('price_btc', 0),  # Price in BTC
            data.get('price_usd', 0),  # Price in USD
            value,  # Position Value USD
            value_pct,  # % of Portfolio
            weight_pct,  # Weight %
        ]
        table_data.append(row)
    
    # Sort by weight percentage (descending)
    table_data.sort(key=lambda x: x[7], reverse=True)
    
    # Add totals row
    table_data.append([
        "TOTAL", "", "", "", "", 
        total_value, 100.0, 100.0
    ])
    
    headers = ["Symbol", "Rank", "Quantity", "Price BTC", "Price USD", 
               "Value USD", "% of Port", "Weight %"]
    
    # Print the table
    print(tabulate(table_data, headers=headers, tablefmt="grid", 
                  floatfmt={"Quantity": ".4f", "Price BTC": ".8f", "Price USD": ".2f", 
                            "Value USD": ".2f", "% of Port": ".2f", "Weight %": ".2f"}))


def backtest_rank_altbtc_short(df: pd.DataFrame,
                               btc_w: float = BTC_W,
                               alt_w: float = ALT_W,
                               top_n: int = TOP_N,
                               excluded: list = None,
                               start_cap: float = START_CAP,
                               detailed_output: bool = True) -> tuple[pd.DataFrame, dict, pd.DataFrame]:
    """
    Backtest the BTC long vs ALT short strategy.
    
    Args:
        df: DataFrame with prepared cryptocurrency data
        btc_w: Weight of BTC position (0-1)
        alt_w: Weight of ALT position (0-1)
        top_n: Number of top altcoins to include in the short basket
        excluded: List of symbols to exclude from the short basket
        start_cap: Initial capital in USD
        detailed_output: Whether to save detailed weekly position data
        
    Returns:
        Tuple of (performance DataFrame, summary dictionary, detailed_positions DataFrame)
    """
    if excluded is None:
        excluded = EXCLUDED
        
    weeks = sorted(df["rebalance_ts"].unique())
    equity = start_cap

    btc_qty = 0.0
    alt_qty = {}  # Symbol -> quantity
    alt_weights = {}  # Symbol -> weight
    alt_values = {}  # Symbol -> USD value
    prev_alt_data = {}  # Symbol -> dict with price data for previous week
    
    rows = []
    detailed_positions = []  # To store detailed position data for each week
    cum_btc_pnl = cum_alt_pnl = 0.0
    total_alt_pnl_btc = 0.0

    print_header(f"BACKTEST: {btc_w*100:.0f}% BTC + {alt_w*100:.0f}% ALT Short (Top {top_n})")
    print(f"Date Range: {pd.Timestamp(weeks[0]).date()} to {pd.Timestamp(weeks[-1]).date()}")
    print(f"Excluded Tokens: {', '.join(sorted(excluded))}")
    print(f"Initial Capital: ${start_cap:,.2f} USD")

    for i in range(len(weeks) - 1):
        t0, t1 = weeks[i], weeks[i + 1]
        w0 = df[df.rebalance_ts == t0].set_index('sym')
        w1 = df[df.rebalance_ts == t1].set_index('sym')

        # BTC prices
        try:
            btc_price0 = w0["btc_price_usd"].mean()
            btc_price1 = w1["btc_price_usd"].mean()
            if pd.isna(btc_price0) or pd.isna(btc_price1) or btc_price0 == 0:
                raise ValueError("BTC price is NaN or zero")
        except Exception as e:
            print(f"Error getting BTC price: {e}")
            if i == 0:
                print("Cannot initialize positions without BTC price.")
                return pd.DataFrame(), {}, pd.DataFrame()
            else:
                print("Holding previous positions due to missing BTC price.")
                if rows:
                    last_row = rows[-1]
                    rows.append({**last_row, 'Date': pd.Timestamp(t1), 'BTC_Price_USD': None})
                continue

        # Update alt price data for the current week
        current_alt_data = {}
        for sym in w1.index:
            if sym in excluded:
                continue
                
            current_alt_data[sym] = {
                'rank': w1.at[sym, 'rank'],
                'price_btc': w1.at[sym, 'price_btc'],
                'price_usd': w1.at[sym, 'price_usd'],
                'mcap_btc': w1.at[sym, 'mcap_btc'],
                'mcap_usd': w1.at[sym, 'market_cap_usd']
            }

        # Week performance calculation or initialization
        if i == 0:
            # Initialize positions
            print_header(f"INITIALIZATION: {pd.Timestamp(t0).date()}", width=100)
            
            # Initialize BTC position
            btc_qty = (btc_w * equity) / btc_price0
            btc_value = btc_qty * btc_price0
            print(f"BTC Long Position: {btc_qty:.6f} BTC @ ${btc_price0:,.2f}/BTC = ${btc_value:,.2f}")
            
            # Store BTC position details
            if detailed_output:
                detailed_positions.append({
                    "Date": pd.Timestamp(t0),
                    "Symbol": "BTC",
                    "Type": "LONG",
                    "Weight": btc_w,
                    "Quantity": btc_qty,
                    "Price_BTC": 1.0,
                    "Price_USD": btc_price0,
                    "Value_USD": btc_value,
                    "PnL_BTC": 0.0,
                    "PnL_USD": 0.0
                })

            # Initialize ALT short basket
            alt_notional_usd_target = alt_w * equity
            alts_df_t0 = w0[~w0.index.isin(excluded)].nsmallest(top_n, "rank")
            actual_alt_usd_value_total = 0.0
            
            print(f"\nALT Short Position Target: ${alt_notional_usd_target:,.2f}")
            
            if not alts_df_t0.empty:
                tot_mcap = alts_df_t0["mcap_btc"].sum()
                
                if tot_mcap > 0 and not pd.isna(tot_mcap):
                    alt_data = {}  # For tabular display
                    
                    for sym, r in alts_df_t0.iterrows():
                        if pd.isna(r.price_btc) or r.price_btc == 0 or pd.isna(r.mcap_btc):
                            continue
                            
                        weight = r.mcap_btc / tot_mcap
                        alt_weights[sym] = weight
                        
                        alt_usd_target_sym = alt_notional_usd_target * weight
                        qty = -(alt_usd_target_sym / (r.price_btc * btc_price0))
                        alt_qty[sym] = qty
                        
                        actual_usd_value_sym = abs(qty * r.price_btc * btc_price0)
                        alt_values[sym] = actual_usd_value_sym
                        actual_alt_usd_value_total += actual_usd_value_sym
                        
                        # Store data for display
                        alt_data[sym] = {
                            'rank': r.rank,
                            'qty': qty,
                            'price_btc': r.price_btc,
                            'price_usd': r.price_usd,
                            'mcap_btc': r.mcap_btc,
                            'target_usd': alt_usd_target_sym,
                            'actual_usd': actual_usd_value_sym,
                            'weight': weight
                        }
                        
                        # Store for price comparison next week
                        prev_alt_data[sym] = {
                            'price_btc': r.price_btc, 
                            'price_usd': r.price_usd
                        }
                        
                        # Store detailed position data
                        if detailed_output:
                            detailed_positions.append({
                                "Date": pd.Timestamp(t0),
                                "Symbol": sym,
                                "Type": "SHORT",
                                "Weight": weight,
                                "Quantity": qty,
                                "Price_BTC": r.price_btc,
                                "Price_USD": r.price_usd,
                                "Value_USD": actual_usd_value_sym,
                                "PnL_BTC": 0.0,
                                "PnL_USD": 0.0
                            })
                    
                    # Print the ALT positions table
                    print_alt_portfolio_table(alt_data, alt_weights, alt_values, "ALT SHORT BASKET")
                    
                else:
                    print("\nWarning: Total mcap_btc zero or NaN. No ALT shorts initialized.")
                    alt_qty = {}
            
            # Portfolio summary
            print_section("PORTFOLIO SUMMARY")
            print(f"BTC Long Value: ${btc_value:,.2f} ({btc_value/equity:.2%} of portfolio)")
            print(f"ALT Short Value: ${actual_alt_usd_value_total:,.2f} ({actual_alt_usd_value_total/equity:.2%} of portfolio)")
            print(f"Cash: ${equity - btc_value - actual_alt_usd_value_total:,.2f}")
            print(f"Total Equity: ${equity:,.2f}")
            
            rows.append({
                "Date": pd.Timestamp(t0),
                "Equity_USD": equity,
                "BTC_Price_USD": btc_price0,
                "BtcQty": btc_qty,
                "BtcHold_USD": btc_qty * btc_price0,
                "AltShortTarget_USD": alt_notional_usd_target,
                "AltShortActual_USD": actual_alt_usd_value_total,
                "AltShortCount": len(alt_qty),
                "Weekly_BTC_PNL_USD": 0.0,
                "Weekly_ALT_PNL_USD": 0.0,
                "Cum_BTC_PNL_USD": 0.0,
                "Cum_ALT_PNL_USD": 0.0,
                "Cum_ALT_PNL_BTC": 0.0,
                "Weekly_Return_Pct": 0.0
            })
            continue

        # Weekly performance calculation
        print_header(f"WEEK {i+1}: {pd.Timestamp(t0).date()} → {pd.Timestamp(t1).date()}", width=100)
        
        # Calculate BTC position P/L
        btc_pnl_usd = (btc_price1 - btc_price0) * btc_qty
        btc_return_pct = ((btc_price1 - btc_price0) / btc_price0) * 100
        btc_value = btc_qty * btc_price1
        
        print_section("BTC POSITION PERFORMANCE")
        print(f"BTC Price Change: ${btc_price0:,.2f} → ${btc_price1:,.2f} ({btc_return_pct:+.2f}%)")
        print(f"BTC Position P/L: {btc_pnl_usd:+,.2f} USD")
        print(f"Current BTC Value: {btc_value:,.2f} USD")
        
        # Store BTC position details
        if detailed_output:
            detailed_positions.append({
                "Date": pd.Timestamp(t1),
                "Symbol": "BTC",
                "Type": "LONG",
                "Weight": btc_w,
                "Quantity": btc_qty,
                "Price_BTC": 1.0,
                "Price_USD": btc_price1,
                "Value_USD": btc_value,
                "PnL_BTC": 0.0,  # BTC doesn't have BTC-denominated P/L
                "PnL_USD": btc_pnl_usd
            })

        # Calculate ALT positions P/L
        print_section("ALT SHORT POSITIONS PERFORMANCE")
        
        if not alt_qty:
            print("No ALT positions to track.")
            weekly_alt_pnl_btc = weekly_alt_pnl_usd = 0
        else:
            # Prepare data for table display
            alt_pnl_data = []
            weekly_alt_pnl_btc = 0.0
            weekly_alt_pnl_usd = 0.0
            current_alt_weights = {}
            current_alt_values = {}
            
            # Calculate total market cap for weight calculation
            total_mcap_btc = sum(current_alt_data[sym]['mcap_btc'] for sym in alt_qty.keys() 
                              if sym in current_alt_data)
            
            for sym, qty_held in alt_qty.items():
                row_data = []
                
                if sym in w0.index and sym in w1.index:
                    p0_btc = w0.at[sym, "price_btc"]
                    p1_btc = w1.at[sym, "price_btc"]
                    p0_usd = w0.at[sym, "price_usd"]
                    p1_usd = w1.at[sym, "price_usd"]
                    mcap_btc = w1.at[sym, "mcap_btc"] 
                    rank = w1.at[sym, "rank"]
                    
                    # Calculate weight
                    weight = mcap_btc / total_mcap_btc if total_mcap_btc else 0
                    current_alt_weights[sym] = weight
                    
                    # Calculate position value
                    pos_value_usd = abs(qty_held * p1_btc * btc_price1)
                    current_alt_values[sym] = pos_value_usd
                    
                    if not pd.isna(p0_btc) and not pd.isna(p1_btc):
                        # Calculate P/L in BTC and USD
                        pnl_btc = (p1_btc - p0_btc) * qty_held
                        pnl_usd = pnl_btc * btc_price1
                        weekly_alt_pnl_btc += pnl_btc
                        weekly_alt_pnl_usd += pnl_usd
                        
                        # Calculate percentage changes
                        price_change_pct = ((p1_btc - p0_btc) / p0_btc) * 100
                        price_change_usd_pct = ((p1_usd - p0_usd) / p0_usd) * 100
                        
                        # Add to data for table display
                        row_data = [
                            sym,                    # Symbol
                            rank,                   # Rank
                            qty_held,               # Quantity
                            p0_btc,                 # Entry Price (BTC)
                            p1_btc,                 # Current Price (BTC)
                            price_change_pct,       # Price Change %
                            p1_usd,                 # Current Price (USD)
                            price_change_usd_pct,   # USD Price Change %
                            pos_value_usd,          # Position Value USD
                            pnl_btc,                # P/L in BTC
                            pnl_usd,                # P/L in USD
                            weight * 100            # Current Weight %
                        ]
                        
                        # Store detailed position data
                        if detailed_output:
                            detailed_positions.append({
                                "Date": pd.Timestamp(t1),
                                "Symbol": sym,
                                "Type": "SHORT",
                                "Weight": weight,
                                "Quantity": qty_held,
                                "Price_BTC": p1_btc,
                                "Price_USD": p1_usd,
                                "Value_USD": pos_value_usd,
                                "PnL_BTC": pnl_btc,
                                "PnL_USD": pnl_usd
                            })
                    else:
                        row_data = [sym, rank, qty_held, "N/A", "N/A", "N/A", "N/A", "N/A", "N/A", "N/A", "N/A", "N/A"]
                
                if row_data:
                    alt_pnl_data.append(row_data)
            
            # Sort by weight (descending)
            if alt_pnl_data:
                alt_pnl_data.sort(key=lambda x: x[11] if isinstance(x[11], (int, float)) else 0, reverse=True)
                
                # Add totals row
                alt_pnl_data.append([
                    "TOTAL", "", "", "", "", "", "", "", 
                    sum(current_alt_values.values()), 
                    weekly_alt_pnl_btc, 
                    weekly_alt_pnl_usd, 
                    100.0
                ])
                
                # Print table
                headers = [
                    "Symbol", "Rank", "Quantity", "Entry Price", "Current Price", "Price Change%", 
                    "USD Price", "USD Change%", "Position Value", "P/L (BTC)", "P/L (USD)", "Weight%"
                ]
                
                alt_performance_table = tabulate(alt_pnl_data, headers=headers, tablefmt="grid", 
                                            floatfmt={"Quantity": ".4f", "Entry Price": ".8f", "Current Price": ".8f", 
                                                     "Price Change%": ".2f", "USD Price": ".2f", "USD Change%": ".2f",
                                                     "Position Value": ".2f", "P/L (BTC)": "+.6f", "P/L (USD)": "+.2f",
                                                     "Weight%": ".2f"})
                print(alt_performance_table)
            else:
                print("No valid ALT positions to display.")

        # Calculate weekly totals
        total_weekly_pnl = btc_pnl_usd + weekly_alt_pnl_usd
        weekly_return_pct = (total_weekly_pnl / equity) * 100
        
        # Update running totals
        cum_btc_pnl += btc_pnl_usd
        cum_alt_pnl += weekly_alt_pnl_usd
        total_alt_pnl_btc += weekly_alt_pnl_btc
        equity += total_weekly_pnl
        
        # Print week summary
        print_section("WEEK SUMMARY")
        print(f"BTC P/L:        {btc_pnl_usd:+,.2f} USD")
        print(f"ALT P/L:        {weekly_alt_pnl_usd:+,.2f} USD ({weekly_alt_pnl_btc:+.6f} BTC)")
        print(f"Total P/L:      {total_weekly_pnl:+,.2f} USD ({weekly_return_pct:+.2f}%)")
        print(f"Cumulative P/L: {cum_btc_pnl + cum_alt_pnl:+,.2f} USD")
        print(f"Current Equity: {equity:,.2f} USD")
        
        if equity <= 0 or pd.isna(equity):
            print("\nEquity invalid or below zero, stopping backtest.")
            break

        # Rebalance for next week
        print_section("REBALANCING FOR NEXT WEEK")
        
        # Rebalance BTC position
        btc_qty_old = btc_qty
        btc_qty = (btc_w * equity) / btc_price1
        btc_change_pct = ((btc_qty - btc_qty_old) / btc_qty_old) * 100 if btc_qty_old != 0 else 0
        print(f"BTC Long: {btc_qty_old:.6f} → {btc_qty:.6f} ({btc_change_pct:+.2f}%)")
        
        # Rebalance ALT shorts
        alt_notional_usd_target = alt_w * equity
        alts_df_t1 = w1[~w1.index.isin(excluded)].nsmallest(top_n, "rank")
        new_alt_qty = {}
        actual_alt_usd_value_total = 0.0
        
        if not alts_df_t1.empty:
            tot_mcap = alts_df_t1["mcap_btc"].sum()
            
            if tot_mcap > 0 and not pd.isna(tot_mcap):
                # Check for changes in the basket composition
                old_symbols = set(alt_qty.keys())
                new_symbols = set(alts_df_t1.index)
                added = new_symbols - old_symbols
                removed = old_symbols - new_symbols
                
                if added:
                    print(f"Added to basket: {', '.join(sorted(added))}")
                if removed:
                    print(f"Removed from basket: {', '.join(sorted(removed))}")
                
                # Calculate new quantities
                alt_data = {}
                
                for sym, r in alts_df_t1.iterrows():
                    if not pd.isna(r.price_btc) and r.price_btc != 0 and not pd.isna(r.mcap_btc):
                        weight = r.mcap_btc / tot_mcap
                        alt_weights[sym] = weight
                        
                        alt_usd_target_sym = alt_notional_usd_target * weight
                        qty = -(alt_usd_target_sym / (r.price_btc * btc_price1))
                        new_alt_qty[sym] = qty
                        
                        value = abs(qty * r.price_btc * btc_price1)
                        alt_values[sym] = value
                        actual_alt_usd_value_total += value
                        
                        # Store data for next iteration
                        alt_data[sym] = {
                            'rank': r.rank,
                            'qty': qty,
                            'price_btc': r.price_btc,
                            'price_usd': r.price_usd,
                            'mcap_btc': r.mcap_btc
                        }
                        
                        # Store for price comparison
                        prev_alt_data[sym] = {
                            'price_btc': r.price_btc,
                            'price_usd': r.price_usd
                        }
                
                # Print rebalanced portfolio
                if alt_data:
                    print_alt_portfolio_table(alt_data, alt_weights, alt_values, "REBALANCED ALT SHORT BASKET")
                else:
                    print("No valid ALTs in rebalanced basket.")
            else:
                print("Warning: Total market cap is zero or NaN. Clearing ALT short positions.")
        else:
            print("No altcoins available. Clearing ALT short positions.")
        
        alt_qty = new_alt_qty

        # Save performance metrics for this week
        rows.append({
            "Date": pd.Timestamp(t1),
            "Equity_USD": equity,
            "BTC_Price_USD": btc_price1,
            "BtcQty": btc_qty,
            "BtcHold_USD": btc_qty * btc_price1,
            "AltShortTarget_USD": alt_notional_usd_target,
            "AltShortActual_USD": actual_alt_usd_value_total,
            "AltShortCount": len(alt_qty),
            "Weekly_BTC_PNL_USD": btc_pnl_usd,
            "Weekly_ALT_PNL_USD": weekly_alt_pnl_usd,
            "Cum_BTC_PNL_USD": cum_btc_pnl,
            "Cum_ALT_PNL_USD": cum_alt_pnl,
            "Cum_ALT_PNL_BTC": total_alt_pnl_btc,
            "Weekly_Return_Pct": weekly_return_pct
        })

    print_header("BACKTEST COMPLETE")
    perf_df = pd.DataFrame(rows)
    
    # Create detailed positions DataFrame
    detailed_df = pd.DataFrame(detailed_positions) if detailed_positions else pd.DataFrame()
    
    # Calculate final equity and BTC equivalent
    final_btc_price = perf_df.iloc[-1]["BTC_Price_USD"] if not perf_df.empty and "BTC_Price_USD" in perf_df.columns else 0
    btc_equiv = equity / final_btc_price if final_btc_price and final_btc_price != 0 else 0
    
    # Calculate summary statistics
    total_return_pct = ((equity - start_cap) / start_cap) * 100
    weekly_returns = perf_df["Weekly_Return_Pct"].dropna().values if not perf_df.empty else []
    annualized_return = total_return_pct * (52 / len(weekly_returns)) if weekly_returns.size > 0 else 0
    max_drawdown = calculate_max_drawdown(perf_df) if not perf_df.empty else 0
    
    # Assemble summary dictionary
    summary = {
        "cum_btc_pnl": cum_btc_pnl,
        "cum_alt_pnl": cum_alt_pnl,
        "cum_alt_pnl_btc": total_alt_pnl_btc,
        "final_equity": equity,
        "btc_equiv": btc_equiv,
        "total_return_pct": total_return_pct,
        "annualized_return": annualized_return,
        "max_drawdown": max_drawdown,
        "sharpe_ratio": calculate_sharpe_ratio(weekly_returns) if weekly_returns.size > 0 else 0,
        "sortino_ratio": calculate_sortino_ratio(weekly_returns) if weekly_returns.size > 0 else 0,
        "win_rate": np.mean(weekly_returns > 0) * 100 if weekly_returns.size > 0 else 0,
    }
    
    return perf_df, summary, detailed_df


def calculate_max_drawdown(perf_df: pd.DataFrame) -> float:
    """Calculate maximum drawdown from equity curve."""
    if "Equity_USD" not in perf_df.columns or perf_df.empty:
        return 0.0
    
    equity = perf_df["Equity_USD"].values
    peak = np.maximum.accumulate(equity)
    drawdown = (equity - peak) / peak
    return abs(min(drawdown)) * 100  # Convert to percentage


def calculate_sharpe_ratio(returns: np.ndarray, risk_free_rate: float = 0.02) -> float:
    """Calculate annualized Sharpe ratio from weekly returns."""
    if returns.size == 0:
        return 0.0
    
    # Convert weekly returns to annualized values
    annualized_return = np.mean(returns) * 52
    annualized_volatility = np.std(returns) * np.sqrt(52)
    
    if annualized_volatility == 0:
        return 0.0
        
    return (annualized_return - risk_free_rate) / annualized_volatility


def calculate_sortino_ratio(returns: np.ndarray, risk_free_rate: float = 0.02) -> float:
    """Calculate annualized Sortino ratio from weekly returns."""
    if returns.size == 0:
        return 0.0
    
    # Calculate downside deviation (only negative returns)
    negative_returns = returns[returns < 0]
    
    if negative_returns.size == 0:
        return np.inf  # No negative returns means infinite Sortino ratio
    
    downside_deviation = np.std(negative_returns) * np.sqrt(52)
    
    if downside_deviation == 0:
        return 0.0
        
    annualized_return = np.mean(returns) * 52
    return (annualized_return - risk_free_rate) / downside_deviation


def plot_equity_curve(perf_df: pd.DataFrame, summary: dict, start_date: dt.datetime, end_date: dt.datetime) -> plt.Figure:
    """Plot equity curve with drawdowns and key metrics."""
    if not perf_df.empty and "Equity_USD" in perf_df.columns:
        plot_data = perf_df.dropna(subset=["Equity_USD", "Date"])
        if not plot_data.empty:
            # Create subplots: equity curve and weekly returns
            fig, (ax1, ax2) = plt.subplots(2, 1, figsize=(12, 10), 
                                           gridspec_kw={'height_ratios': [3, 1]})
            
            # --- Equity Curve (Top Plot) ---
            ymin = min(START_CAP, plot_data["Equity_USD"].min()) * 0.9
            ymax = max(START_CAP, plot_data["Equity_USD"].max()) * 1.1
            ymin = max(0, ymin)
            if ymin >= ymax:
                ymax = ymin * 1.2 if ymin > 0 else START_CAP * 1.1
                
            fmt = ScalarFormatter(useOffset=False)
            fmt.set_scientific(False)
            
            # Plot equity curve
            ax1.plot(plot_data["Date"], plot_data["Equity_USD"], marker=".", linestyle="-", 
                    color='blue', linewidth=2, label="Portfolio Value")
            
            # Plot BTC buy-and-hold for comparison
            if "BTC_Price_USD" in plot_data.columns:
                initial_btc_price = plot_data["BTC_Price_USD"].iloc[0]
                btc_qty = START_CAP / initial_btc_price
                btc_value = plot_data["BTC_Price_USD"] * btc_qty
                ax1.plot(plot_data["Date"], btc_value, marker="", linestyle="--", 
                        color='orange', linewidth=1.5, label="BTC Buy & Hold")
            
            title = f"{BTC_W*100:.0f}% BTC long vs {ALT_W*100:.0f}% ALT short (Top {TOP_N})"
            date_range = f"[{start_date.date()} to {end_date.date()}]"
            ax1.set_title(f"{title}\n{date_range}", fontsize=14)
            
            ax1.set_xlabel("")  # We'll put the label on the bottom plot
            ax1.set_ylabel("Equity (USD)", fontsize=12)
            ax1.set_ylim(ymin, ymax)
            ax1.grid(True, which="major", linestyle="--", alpha=0.7)
            ax1.grid(True, which="minor", linestyle=":", alpha=0.5)
            ax1.minorticks_on()
            ax1.yaxis.set_major_formatter(fmt)
            ax1.axhline(START_CAP, color="red", linestyle="--", linewidth=1, 
                       label=f"Initial Capital (${START_CAP:,.0f})")
            
            # Calculate drawdown for shading
            equity = plot_data["Equity_USD"].values
            dates = plot_data["Date"].values
            peak = np.maximum.accumulate(equity)
            drawdown = (equity - peak) / peak
            
            # Color the background based on drawdown severity
            for i in range(1, len(drawdown)):
                if drawdown[i] < -0.05:  # More than 5% drawdown
                    color = 'salmon'
                    alpha = min(0.3, abs(drawdown[i]))
                    ax1.axvspan(dates[i-1], dates[i], color=color, alpha=alpha)
            
            # Add key metrics as text box
            metrics_text = (
                f"Total Return: {summary['total_return_pct']:.2f}%\n"
                f"Annualized: {summary['annualized_return']:.2f}%\n"
                f"Max Drawdown: {summary['max_drawdown']:.2f}%\n"
                f"Sharpe Ratio: {summary['sharpe_ratio']:.2f}\n"
                f"Win Rate: {summary['win_rate']:.1f}%"
            )
            ax1.text(0.02, 0.02, metrics_text, transform=ax1.transAxes, fontsize=10,
                   bbox=dict(boxstyle="round,pad=0.3", fc="wheat", alpha=0.7))
            
            ax1.legend(loc='upper left')
            
            # --- Weekly Returns (Bottom Plot) ---
            if "Weekly_Return_Pct" in plot_data.columns:
                returns = plot_data["Weekly_Return_Pct"]
                
                # Create bar plot of weekly returns
                colors = ['green' if r >= 0 else 'red' for r in returns]
                ax2.bar(plot_data["Date"], returns, color=colors, alpha=0.7, width=6)
                
                ax2.axhline(0, color='black', linestyle='-', linewidth=0.5)
                ax2.set_xlabel("Date", fontsize=12)
                ax2.set_ylabel("Weekly Return (%)", fontsize=12)
                ax2.yaxis.set_major_formatter(PercentFormatter())
                ax2.grid(True, axis='y', linestyle='--', alpha=0.5)
                
                # Set date formatting to match the top plot
                fig.autofmt_xdate()
            
            plt.tight_layout()
            return fig
        
    # Return None if we couldn't create a plot
    return None


def plot_btc_vs_alts(perf_df: pd.DataFrame) -> plt.Figure:
    """Plot separate performance of BTC long vs ALT short legs."""
    if not perf_df.empty and all(col in perf_df.columns for col in ["Cum_BTC_PNL_USD", "Cum_ALT_PNL_USD", "Date"]):
        # Create figure
        fig, ax = plt.subplots(figsize=(12, 6))
        
        # Plot cumulative P/L for each leg
        ax.plot(perf_df["Date"], perf_df["Cum_BTC_PNL_USD"], 
                marker="", linestyle="-", color='blue', linewidth=2, 
                label="BTC Long Cumulative P/L")
        
        ax.plot(perf_df["Date"], perf_df["Cum_ALT_PNL_USD"], 
                marker="", linestyle="-", color='red', linewidth=2, 
                label="ALT Short Cumulative P/L")
        
        # Plot total P/L
        total_pnl = perf_df["Cum_BTC_PNL_USD"] + perf_df["Cum_ALT_PNL_USD"]
        ax.plot(perf_df["Date"], total_pnl, 
                marker="", linestyle="-", color='green', linewidth=2, 
                label="Total Cumulative P/L")
        
        # Style the plot
        ax.set_title("BTC Long vs ALT Short - Cumulative P/L Contribution", fontsize=14)
        ax.set_xlabel("Date", fontsize=12)
        ax.set_ylabel("Cumulative P/L (USD)", fontsize=12)
        
        # Add zero line
        ax.axhline(0, color='black', linestyle='-', linewidth=0.5)
        
        # Add grid and legend
        ax.grid(True, linestyle='--', alpha=0.7)
        ax.legend(loc='best')
        
        # Format dates on x-axis
        fig.autofmt_xdate()
        plt.tight_layout()
        
        return fig
    
    return None


def export_detailed_report(perf_df: pd.DataFrame, summary: dict, detailed_df: pd.DataFrame, 
                           start_date: dt.datetime, end_date: dt.datetime):
    """Export detailed backtest report to CSV files and plots."""
    # Create reports directory if it doesn't exist
    REPORTS_DIR.mkdir(exist_ok=True)
    
    # Generate timestamp for unique filenames
    timestamp = dt.datetime.now().strftime("%Y%m%d_%H%M%S")
    
    # Export performance dataframe
    if not perf_df.empty:
        perf_file = REPORTS_DIR / f"performance_{timestamp}.csv"
        perf_df.to_csv(perf_file, index=False)
        print(f"Exported performance data to {perf_file}")
    
    # Export detailed positions dataframe
    if not detailed_df.empty:
        detail_file = REPORTS_DIR / f"positions_{timestamp}.csv"
        detailed_df.to_csv(detail_file, index=False)
        print(f"Exported detailed position data to {detail_file}")
    
    # Export summary as text file
    summary_file = REPORTS_DIR / f"summary_{timestamp}.txt"
    with open(summary_file, "w") as f:
        f.write(f"Backtest Summary: {start_date.date()} to {end_date.date()}\n")
        f.write(f"Strategy: {BTC_W*100:.0f}% BTC long vs {ALT_W*100:.0f}% ALT short (Top {TOP_N})\n\n")
        
        f.write("Performance Metrics:\n")
        f.write(f"Initial Capital: ${START_CAP:,.2f}\n")
        f.write(f"Final Equity: ${summary['final_equity']:,.2f}\n")
        f.write(f"Total Return: {summary['total_return_pct']:+.2f}%\n")
        f.write(f"Annualized Return: {summary['annualized_return']:+.2f}%\n")
        f.write(f"Maximum Drawdown: {summary['max_drawdown']:.2f}%\n")
        f.write(f"Sharpe Ratio: {summary['sharpe_ratio']:.2f}\n")
        f.write(f"Sortino Ratio: {summary['sortino_ratio']:.2f}\n")
        f.write(f"Win Rate: {summary['win_rate']:.1f}%\n\n")
        
        f.write("Contribution Analysis:\n")
        f.write(f"BTC Long P/L: ${summary['cum_btc_pnl']:+,.2f}\n")
        f.write(f"ALT Short P/L: ${summary['cum_alt_pnl']:+,.2f} ({summary['cum_alt_pnl_btc']:+.6f} BTC)\n")
        f.write(f"BTC Equivalent Value: {summary['btc_equiv']:.6f} BTC\n")
    
    print(f"Exported summary to {summary_file}")
    
    # Save plots
    equity_fig = plot_equity_curve(perf_df, summary, start_date, end_date)
    if equity_fig:
        equity_plot_file = REPORTS_DIR / f"equity_curve_{timestamp}.png"
        equity_fig.savefig(equity_plot_file, dpi=300, bbox_inches="tight")
        print(f"Exported equity curve plot to {equity_plot_file}")
    
    contribution_fig = plot_btc_vs_alts(perf_df)
    if contribution_fig:
        contrib_plot_file = REPORTS_DIR / f"contribution_{timestamp}.png"
        contribution_fig.savefig(contrib_plot_file, dpi=300, bbox_inches="tight")
        print(f"Exported contribution plot to {contrib_plot_file}")


def main():
    if not CSV_PATH.exists():
        print(f"CSV not found: {CSV_PATH}")
        return
        
    print(f"Loading data from {CSV_PATH}")
    print(f"Date range: {START_DATE.date()} to {END_DATE.date()}")
    
    df = load_and_prepare(CSV_PATH, START_DATE, END_DATE)
    print(f"Loaded {len(df)} rows over {df['rebalance_ts'].nunique()} weeks")
    
    # Run backtest
    perf, summary, detailed = backtest_rank_altbtc_short(df)
    
    # Display summary
    if summary:
        print_header("FINAL SUMMARY")
        print(f"Cumulative BTC P/L : {summary['cum_btc_pnl']:+,.2f} USD")
        print(f"Cumulative ALT P/L : {summary['cum_alt_pnl']:+,.2f} USD ({summary['cum_alt_pnl_btc']:+.6f} BTC)")
        print(f"Final equity       : {summary['final_equity']:,.2f} USD")
        print(f"Total return       : {summary['total_return_pct']:+.2f}%")
        print(f"Annualized return  : {summary['annualized_return']:+.2f}%")
        print(f"Maximum drawdown   : {summary['max_drawdown']:.2f}%")
        print(f"Sharpe ratio       : {summary['sharpe_ratio']:.2f}")
        print(f"Win rate           : {summary['win_rate']:.1f}%")
        print(f"Final BTC equiv    : {summary['btc_equiv']:.6f} BTC")
        
        # Export detailed report
        export_detailed_report(perf, summary, detailed, START_DATE, END_DATE)
        
        # Show plots
        equity_fig = plot_equity_curve(perf, summary, START_DATE, END_DATE)
        if equity_fig:
            plt.figure(equity_fig.number)
            plt.show()
        
        contribution_fig = plot_btc_vs_alts(perf)
        if contribution_fig:
            plt.figure(contribution_fig.number)
            plt.show()
    else:
        print("Backtest did not produce a summary.")


if __name__ == "__main__":
    main()